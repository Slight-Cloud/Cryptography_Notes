# 记录可能考点

## 流程图：

**符号约定**：

* $\text{Sign}_{A}(M)$：用户 A 用私钥对消息 M 进行数字签名。
* $E_{K}(M)$：使用密钥 K 进行加密。
* $H(M)$：哈希函数。
* $||$ 或 $|$：数据拼接。

### 一、 对称加密体系 (Symmetric Key Infrastructure)

这里主要解决**密钥分发**和**基于票据的认证**问题。

#### 1. 集中式密钥分配 (KDC)

* **位置**：Page 8
* **概要**：通信双方均信赖第三方 KDC，由 KDC 生成会话密钥 $K_S$ 并分别加密发给双方。

**流程图示：**

1. **A 申请密钥**：

   $$
   A \to \text{KDC}: ID_A \mid ID_B \mid N_1
   $$
2. **KDC 分发 (核心步骤)**：

   $$
   \text{KDC} \to A: E_{K_A}(K_S \mid ID_B \mid N_1 \mid \underbrace{E_{K_B}(K_S \mid ID_A)}_{\text{Ticket for B}})
   $$
3. **A 转发票据**：

   $$
   A \to B: E_{K_B}(K_S \mid ID_A)
   $$
4. **挑战响应 (验证 $K_S$ 是否生效)**：

   $$
   B \to A: E_{K_S}(N_2)
   $$

   $$
   A \to B: E_{K_S}(f(N_2))
   $$

#### 2. 分散式密钥分配 (Decentralized Key Distribution)

* **位置**：Page 8
* **概要**：不依赖 KDC，通信双方利用**预先共享的主密钥 ($K_{MK}$)** 直接协商会话密钥，由响应方 (B) 生成会话密钥。

**流程图示：**

1. **A 发起请求 (明文)**：

   $$
   A \to B: \text{Request} \mid N_1
   $$

   * 说明：$N_1$ 为随机数 (nonce)，用于防止重放和关联后续响应。
2. **B 生成密钥并响应 (核心步骤)**：

   $$
   B \to A: E_{K_{MK}}( K_S \mid \text{Request} \mid ID_B \mid f(N_1) \mid N_2 )
   $$

   * 说明：B 生成会话密钥 $K_S$。
   * $f(N_1)$：对 A 的随机数进行变换，证明 B 拥有 $K_{MK}$ 且这是对当前请求的响应。
   * $N_2$：B 的随机数，用于挑战 A。
3. **A 验证并完成握手**：

   $$
   A \to B: E_{K_S}( f(N_2) )
   $$

   * 说明：A 解密获得 $K_S$，验证 $f(N_1)$ 无误后，使用新会话密钥 $K_S$ 加密 $f(N_2)$ 以响应 B 的挑战，证明自己也成功获取了 $K_S$。

#### 3.. Kerberos 认证协议

* **位置**：Page 13
* **概要**：基于对称加密的“三次握手”式认证（AS验证身份 -> TGS发服务票据 -> 访问服务），实现单点登录 (SSO)。

**关键数据结构 (Ticket)：**

$$
\text{Ticket}_V = E_{K_V}( ID_C \mid \text{Addr}_C \mid ID_V \mid \text{有效期} \mid K_{C,V} )
$$

**流程图示：**

1. **C 请求身份认证 (AS)**：
   $$
   C \to \text{AS}: ID_C \mid ID_{TGS} \mid TS_1
   $$
2. **AS 颁发 TGT (票据授予票据)**：
   $$
   \text{AS} \to C: E_{K_C}(K_{C,TGS} \dots) \mid \text{Ticket}_{TGS}
   $$
3. **C 请求服务授权 (TGS)**：
   $$
   C \to \text{TGS}: ID_V \mid \text{Ticket}_{TGS} \mid \text{Authenticator}_C
   $$
4. **TGS 颁发服务票据**：
   $$
   \text{TGS} \to C: E_{K_{C,TGS}}(K_{C,V} \dots) \mid \text{Ticket}_V
   $$
5. **C 访问服务 (Service)**：
   $$
   C \to V: \text{Ticket}_V \mid \text{Authenticator}'_C
   $$

---

### 二、 非对称加密体系 (Asymmetric Key Infrastructure)

这里主要解决**公钥的信任与获取**问题。

#### 2.1. 公钥权威 (PKA)

* **位置**：Page 9
* **概要**：动态在线查询，每次通信前向权威机构 PKA 索取对方公钥，PKA 对响应进行签名以防篡改。

**流程图示：**

1. **A 查询 B 的公钥**：
   $$
   A \to \text{PKA}: \text{Request} \mid Time_1
   $$
2. **PKA 响应 (带签名)**：
   $$
   \text{PKA} \to A: \text{Sign}_{PKA}(KU_B \mid \text{Request} \mid Time_1)
   $$
3. **A 发起握手**：
   $$
   A \to B: E_{KU_B}(ID_A \mid N_1)
   $$
4. **B 反向查询 A 的公钥**：
   $$
   B \to \text{PKA} \dots \to \text{PKA} \to B: \text{Sign}_{PKA}(KU_A \dots)
   $$
5. **B 响应握手**：
   $$
   B \to A: E_{KU_A}(N_1 \mid N_2)
   $$

#### 2.2.公钥证书的一般使用流程 (General Certificate Scheme)

* **概要**：用户向 CA 注册公钥并获取签名证书，通信时双方直接互换证书，利用 CA 的公钥验证对方身份，无需 CA 实时在线参与。

**流程图示：**

**阶段一：证书颁发 (Certificate Authority Generation)**
用户 A 和 B 分别安全地将自己的公钥提交给 CA，CA 用自己的私钥对“时间戳、用户身份、用户公钥”进行签名。

1. **A 申请证书**：
   $$
   A \to \text{CA}: KU_A
   $$
2. **CA 颁发证书**：
   $$
   \text{CA} \to A: C_A = \text{Sign}_{CA}( T_1 \mid ID_A \mid KU_A )
   $$
3. **B 申请与颁发（同理）**：
   $$
   \text{CA} \to B: C_B = \text{Sign}_{CA}( T_2 \mid ID_B \mid KU_B )
   $$

**阶段二：证书交换 (Certificate Exchange)**
A 和 B 在通信开始时交换证书。

1. **A 发送证书给 B**：

   $$
   A \to B: C_A
   $$

   * **验证**：B 使用 CA 的公钥 $KU_{CA}$ 验证 $C_A$ 的签名。如果有效，B 确信 $KU_A$ 属于 $ID_A$ 且在有效期 $T_1$ 内。
2. **B 发送证书给 A**：

   $$
   B \to A: C_B
   $$

   * **验证**：同理，A 验证 B 的身份。

#### 2.3.公钥证书 (X.509 CA)证书申请、颁发、交换

这部分涵盖证书的申请、颁发以及收到证书后的验证逻辑。

##### 2.3.1. 证书申请与颁发 (Issuance)

**概要**：用户提交包含“所有权证明”的请求 (CSR)，CA 验证身份后签发证书。

**流程图示：**

1. **A 提交证书签名请求 (CSR)**：

   $$
   A \to \text{CA}: \text{CSR} = ID_A \mid KU_A \mid \text{Sign}_{KR_A}(ID_A, KU_A)
   $$

   * **核心**：包含 $A$ 的自签名，证明 A 确实拥有该公钥对应的私钥 (Proof of Possession)。
2. **CA 签发证书**：

   $$
   \text{CA} \to A: \text{Cert}_A = \text{TBS} \mid \text{Sign}_{KR_{CA}}( H(\text{TBS}) )
   $$

   * **TBS (To-Be-Signed)**：包含 $ID_A, KU_A, \text{Validity}(T), \text{Issuer}$ 等。

##### 2.3.2.证书验证逻辑 (Verification Logic)

**概要**：收到证书后，必须依次通过完整性、有效期、吊销状态和信任链四重检查。

**逻辑判定流程 (以 B 验证 $Cert_A$ 为例)：**

1. **完整性校验 (Integrity)**：

   $$
   \text{Check: } D_{KU_{CA}}(\text{Signature}) \overset{?}{==} H(\text{TBSCertificate})
   $$

   * *说明：确保“名片”未被篡改。*
2. **有效期校验 (Validity)**：

   $$
   \text{Check: } \text{NotBefore} \le \text{CurrentTime} \le \text{NotAfter}
   $$

   * *说明*：确保证书当前处于生效窗口。
3. **吊销状态 (Revocation)**：

   $$
   \text{验证条件：} \big( \text{Serial}(Cert_A) \notin \text{CRL} \big) \quad \text{或} \quad \big( \text{OCSP\_Query}(Cert_A) = \text{Good} \big)
   $$

   * *说明*：确保私钥未泄露（未进黑名单）。
4. **信任链 (Chain of Trust)**：

   $$
   \text{Check: } \text{Issuer}(Cert_A) \to \dots \to \text{Root CA}_{\text{Trusted}}
   $$

   * *说明*：递归验证直到本地受信任的根证书。

#### 2.4. X.509 认证协议 (Authentication Protocols)

这部分是双方持有对方证书（公钥）后，进行身份确认的握手流程。

**通用符号定义**：

* $A\{ \dots \}$: 数据由 A 发送，且包含 $\text{Sign}_{KR_A}(\dots)$。
* $t_A, t_B$: 时间戳。
* $r_A, r_B$: 随机数 (Nonce)。
* $sgnData$: 协议规定的被签名数据块。
* $E_{KU_X}$: 使用 X 的公钥加密。

##### 2.4.1. 单向认证 (One-Way Authentication)

**概要**：A 向 B 证明身份，B 依赖**时间戳**验证消息新鲜性，防止重放。

**流程图示：**

1. **A 发起认证**：
   $$
   A \to B: A \{ t_A, r_A, ID_B, sgnData, E_{KU_B}(K_{ab}) \}
   $$

**验证逻辑 (B 端)**：

1. 验证 A 的签名 $\to$ 确认来源是 A。
2. 检查 $ID_B$ $\to$ 确认是发给自己的。
3. 检查 $t_A$ $\to$ **确认消息未过期 (防重放关键)**。

##### 2.4.2. 双向认证 (Two-Way Authentication)

**概要**：双方互相认证。A 依赖 B 对随机数 $r_A$ 的响应来验证 B，但 B 验证 A 仍依赖时间戳。需**时钟同步**。

**流程图示：**

1. **A 发起认证**：

   $$
   A \to B: A \{ t_A, r_A, ID_B, sgnData, E_{KU_B}(K_{ab}) \}
   $$
2. **B 响应并反向认证**：

   $$
   B \to A: B \{ t_B, r_B, ID_A, r_A, sgnData \}
   $$

   * *核心*：B 签回了 $r_A$，证明 B 确实收到了第一条消息。

**验证逻辑**：

* **B 验证 A**：依赖 $t_A$ (同单向认证)。
* **A 验证 B**：依赖 $r_A$ 的返回 (Challenge-Response) + $t_B$。

##### 2.4.3. 三向认证 (Three-Way Authentication)

**概要**：双方互相认证，**完全不依赖时钟同步**，通过第三步 A 对 $r_B$ 的签名返回，消除对时间戳的需求。

**流程图示：**

1. **A 发起 (Challenge A)**：

   $$
   A \to B: A \{ t_A, r_A, ID_B, sgnData, E_{KU_B}(K_{ab}) \}
   $$

   * *注意*：此处 $t_A$ 被视为无意义的随机数据，B 不检查其时间有效性。
2. **B 响应 (Response A + Challenge B)**：

   $$
   B \to A: B \{ t_B, r_B, ID_A, r_A, sgnData \}
   $$

   * *说明*：B 证明了自己在线 (回传 $r_A$)，并发出挑战 $r_B$。
3. **A 最终确认 (Response B)**：

   $$
   A \to B: A \{ r_B \}
   $$

   * *核心*：A 签回 $r_B$。

**验证逻辑 (B 端最终检查)**：

* **B 验证 A**：不再查看 Step 1 的 $t_A$，而是验证 Step 3 中 A 是否正确签回了 $r_B$。只有 A 实时在线才能完成此步。

---

### 三、 网络与传输层安全 (Network & Transport Layer)

#### 1. IPsec (网络层)

* **位置**：Page 15
* **概要**：在 IP 数据包层面提供加密 (ESP) 或仅认证 (AH)，分为传输模式（点对点）和隧道模式（网关对网关）。

**数据包封装结构：**

* **AH (仅完整性校验)：**
  $$
  [\text{IP Header} \mid \mathbf{AH} \mid \text{Payload}]
  $$
* **ESP (加密 + 完整性)：**
  * *传输模式 (保护 Payload)*：
    $$
    [\text{IP Hdr} \mid \mathbf{ESP Hdr} \mid \underbrace{E_K(\text{TCP/Data})}_{\text{Encrypted}} \mid \mathbf{ESP Auth}]
    $$
  * *隧道模式 (保护整个原 IP 包)*：
    $$
    [\text{New IP Hdr} \mid \mathbf{ESP Hdr} \mid \underbrace{E_K(\text{Orig IP Hdr} \mid \text{Data})}_{\text{Encrypted}} \mid \mathbf{ESP Auth}]
    $$

#### 2. SSL/TLS (传输层)

* **位置**：Page 16
* **概要**：通过握手协议协商加密套件、验证身份（证书），并利用非对称加密交换“预主密钥”来生成会话密钥。

**简化握手流程：**

1. **能力协商**：
   $$
   C \to S: \text{ClientHello}(\text{Ver}, \text{Random}_C, \text{Suites})
   $$
2. **服务器响应**：
   $$
   S \to C: \text{ServerHello}(\text{Ver}, \text{Random}_S, \text{Suite}) \mid \text{Cert}_S
   $$
3. **密钥交换 (RSA模式)**：
   $$
   C \to S: E_{KU_S}(\text{Pre-Master Secret})
   $$
4. **生成会话密钥 (不传输)**：
   $$
   K_{Session} = \text{Derive}(\text{Pre-Master}, \text{Random}_C, \text{Random}_S)
   $$
5. **验证与完成**：
   $$
   C \leftrightarrow S: \text{Finished}(\text{MAC}(\text{All Handshake Msgs}))
   $$

---

### 四、 应用层安全 (Application Layer)

#### 1. PGP 电子邮件安全

* **位置**：Page 15
* **概要**：混合加密系统。先压缩，再用随机对称密钥加密消息，最后用接收方公钥加密对称密钥；同时支持数字签名。

**发送流程 (A -> B)：**

1. **签名**：计算哈希并签名。

   $$
   S = \text{Sign}_{A}( H(M) )
   $$
2. **压缩**：

   $$
   Z = \text{ZIP}( M \mid S )
   $$
3. **信封加密 (数字信封)**：生成一次性会话密钥 $K_S$。

   $$
   \text{Cipher} = E_{K_S}(Z)
   $$

   $$
   \text{KeyEnc} = E_{KU_B}(K_S)
   $$
4. **拼接发送**：

   $$
   \text{Result} = \text{KeyEnc} \mid \text{Cipher}
   $$

#### 2. SET 安全电子交易

* **位置**：Page 17
* **概要**：专为支付设计，核心是**双重签名 (Dual Signature)**，实现信息隔离（商家只看订单，银行只看支付）。

**符号**：

* $PI$：支付信息 (给银行)
* $OI$：订单信息 (给商家)

**双重签名流程：**

1. **摘要生成**：
   $$
   H_{PI} = H(PI), \quad H_{OI} = H(OI)
   $$
2. **双重摘要**：
   $$
   \text{POMD} = H( H_{PI} \mid H_{OI} )
   $$
3. **签名**：
   $$
   DS = \text{Sign}_{C}(\text{POMD})
   $$

**发送给商家的请求：**

$$
C \to \text{Merchant}: \underbrace{OI \mid DS \mid H_{PI}}_{\text{商家验证部分}} \mid \underbrace{E_{KU_{Bank}}(PI \mid DS \mid H_{OI})}_{\text{转发给银行部分}}
$$

* 说明：商家利用 $H(OI)$ 和收到的 $H_{PI}$ 验证 $DS$，但无法还原 $PI$；银行同理。

---

## 计算题：

### S-DES 算法

***(1) 生成子密钥 K₁、K₂***

***(2) 加密明文 `01110010`***

#### 题目附录：算法组件

##### 置换表

| 组件             | 映射规则                 | 说明                 |
| ---------------- | ------------------------ | -------------------- |
| **P10**    | `3 5 2 7 4 10 1 9 8 6` | 10位密钥初始置换     |
| **P8**     | `6 3 7 4 8 5 10 9`     | 8位子密钥生成置换    |
| **IP**     | `2 6 3 1 4 8 5 7`      | 初始置换             |
| **IP⁻¹** | `4 1 3 5 7 2 8 6`      | 逆初始置换           |
| **EP**     | `4 1 2 3 2 3 4 1`      | 扩展置换（4位→8位） |
| **P4**     | `2 4 3 1`              | 4位置换              |

##### S盒

**S0 盒**：

```
    列  0   1   2   3
行 0 |  1   0   3   2
   1 |  3   2   1   0
   2 |  0   2   1   3
   3 |  3   1   3   2
```

**S1 盒**：

```
    列  0   1   2   3
行 0 |  0   1   2   3
   1 |  2   0   1   3
   2 |  3   0   1   0
   3 |  2   1   0   3
```

#### (1)子密钥生成

##### Step 1: P10 置换

**输入**：`1010000010`

按 P10 规则 `3 5 2 7 4 10 1 9 8 6` 重排：

```
位置：  1  2  3  4  5  6  7  8  9  10
原值：  1  0  1  0  0  0  0  0  1  0
       ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
P10取： 3  5  2  7  4  10 1  9  8  6
结果：  1  0  0  0  0  0  1  1  0  0
```

**P10 输出**：`1000001100`

##### Step 2: 拆分为左右两部分

- **L₀** = `10000`（前5位）
- **R₀** = `01100`（后5位）

##### Step 3: 生成 K₁（LS-1 → P8）

###### 3.1 循环左移1位（LS-1）

- **L₁** = `00001`（`10000` 左移1位）
- **R₁** = `11000`（`01100` 左移1位）

**合并**：`0000111000`

###### 3.2 P8 置换

按 P8 规则 `6 3 7 4 8 5 10 9` 取位：

```
位置：  1  2  3  4  5  6  7  8  9  10
原值：  0  0  0  0  1  1  1  0  0  0
       ↓     ↓  ↓  ↓  ↓  ↓     ↓  ↓
P8取：  6     3  7  4  8  5     10 9
结果：  1     0  1  0  0  1     0  0
```

**K₁** = `10100100`

##### Step 4: 生成 K₂（LS-2 → P8）

###### 4.1 在 L₁、R₁ 基础上继续循环左移2位（LS-2）

- **L₂** = `00100`（`00001` 左移2位）
- **R₂** = `00011`（`11000` 左移2位）

**合并**：`0010000011`

###### 4.2 P8 置换

按 P8 规则 `6 3 7 4 8 5 10 9` 取位：

```
位置：  1  2  3  4  5  6  7  8  9  10
原值：  0  0  1  0  0  0  0  0  1  1
       ↓     ↓  ↓  ↓  ↓  ↓     ↓  ↓
P8取：  6     3  7  4  8  5     10 9
结果：  0     1  0  0  0  0     1  1
```

**K₂** = `01000011`

#### (2)加密明文

##### Step 1: 初始置换（IP）

**输入明文**：`01110010`

按 IP 规则 `2 6 3 1 4 8 5 7` 重排：

```
位置：  1  2  3  4  5  6  7  8
原值：  0  1  1  1  0  0  1  0
       ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
IP取：  2  6  3  1  4  8  5  7
结果：  1  0  1  0  1  0  0  1
```

**IP 输出**：`10101001`

**拆分**：

- **L₀** = `1010`
- **R₀** = `1001`

##### Step 2: 第一轮加密 fₖ(R₀, K₁)

###### 2.1 扩展置换（EP）

对 R₀ = `1001` 应用 EP 规则 `4 1 2 3 2 3 4 1`：

```
R₀位置：     1  2  3  4
R₀值：       1  0  0  1
            ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
EP取位：     4  1  2  3  2  3  4  1
EP(R₀)：     1  1  0  0  0  0  1  1
```

**EP(R₀)** = `11000011`

###### 2.2 与 K₁ 异或

```
EP(R₀)：  1  1  0  0  0  0  1  1
K₁：      1  0  1  0  0  1  0  0
        ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ ⊕
结果：    0  1  1  0  0  1  1  1
```

**异或结果**：`01100111`

###### 2.3 S盒代换

**左半部分** `0110` → S0：

- 行 = `00` (首尾位) = 0
- 列 = `11` (中间位) = 3
- S0[0][3] = 2 = `10`

**右半部分** `0111` → S1：

- 行 = `01` (首尾位) = 1
- 列 = `11` (中间位) = 3
- S1[1][3] = 3 = `11`

**S盒输出**：`1011`

###### 2.4 P4 置换

对 `1011` 应用 P4 规则 `2 4 3 1`：

```
位置：  1  2  3  4
原值：  1  0  1  1
       ↓  ↓  ↓  ↓
P4取：  2  4  3  1
结果：  0  1  1  1
```

**P4 输出**：`0111`

**因此 f(R₀, K₁) = `0111`**

###### 2.5 更新左半部分

```
L₁ = L₀ ⊕ f(R₀, K₁)
   = 1010 ⊕ 0111
   = 1101
```

###### 2.6 交换（SW）

**第一轮结束后**：

- **左半部分** = $R_0$ = `1001`
- **右半部分** = $L_0 \oplus f(R_0, K_1)$ = `1101`

##### Step 3: 第二轮加密 fₖ(R₁, K₂)

**当前状态**：L₁ = `1001`，R₁ = `1101`

###### 3.1 扩展置换（EP）

对 R₁ = `1101` 应用 EP 规则：

```
R₁位置：     1  2  3  4
R₁值：       1  1  0  1
            ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
EP取位：     4  1  2  3  2  3  4  1
EP(R₁)：     1  1  1  0  1  0  1  1
```

**EP(R₁)** = `11101011`

###### 3.2 与 K₂ 异或

```
EP(R₁)：  1  1  1  0  1  0  1  1
K₂：      0  1  0  0  0  0  1  1
        ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ ⊕
结果：    1  0  1  0  1  0  0  0
```

**异或结果**：`10101000`

###### 3.3 S盒代换

**左半部分** `1010` → S0：

- 行 = `10` = 2
- 列 = `01` = 1
- S0[2][1] = 2 = `10`

**右半部分** `1000` → S1：

- 行 = `10` = 2
- 列 = `00` = 0
- S1[2][0] = 3 = `11`

**S盒输出**：`1011`

###### 3.4 P4 置换

对 `1011` 应用 P4 规则：

```
位置：  1  2  3  4
原值：  1  0  1  1
       ↓  ↓  ↓  ↓
P4取：  2  4  3  1
结果：  0  1  1  1
```

**P4 输出**：`0111`

**因此 f(R₁, K₂) = `0111`**

###### 3.5 更新左半部分

```
L₂ = L₁ ⊕ f(R₁, K₂)
   = 1001 ⊕ 0111
   = 1110
```

###### 3.6 合并（无交换）

**第二轮结束**，直接合并 L₂ 和 R₁：

- **合并结果** = L₂ || R₁ = `11101101`

##### Step 4: 逆初始置换（IP⁻¹）

**输入**：`11101101`

按 IP⁻¹ 规则 `4 1 3 5 7 2 8 6` 重排：

```
位置：  1  2  3  4  5  6  7  8
原值：  1  1  1  0  1  1  0  1
       ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
IP⁻¹取：4  1  3  5  7  2  8  6
结果：  0  1  1  1  0  1  1  1
```

**最终密文 C** = `01110111`

#### 答案总结

- **K₁** = `10100100`
- **K₂** = `01000011`
- **密文 C** = `01110111`

---

### RSA 算法手算练习

基础参数

* $p = 7$
* $q = 17$
* $e = 11$

***(1)计算私钥 d***

***(2)加密明文 m = 5***

#### 1. 第一题解答：

##### 参数准备：

* $n = p \times q = 7 \times 17 = 119$
* $\phi(n) = (p-1)(q-1) = 6 \times 16 = 96$

我们需要求解 $d$，满足 $11d \equiv 1 \pmod{96}$。

##### 步骤1：辗转相除法 (Euclidean Algorithm)

计算 $\gcd(96, 11)$：

1. $96 = 8 \times 11 + 8$
2. $11 = 1 \times 8 + 3$
3. $8 = 2 \times 3 + 2$
4. $3 = 1 \times 2 + 1$  <-- 得到余数 1，停止

##### 步骤2：逆向回代 (Extended Euclidean)

我们将余数 1 表示为 11 和 96 的线性组合：

1. 从第4式移项：
   $$
   1 = 3 - 1 \times 2
   $$
2. 代入第3式 ($2 = 8 - 2 \times 3$)：
   $$
   1 = 3 - 1 \times (8 - 2 \times 3) = 3 - 8 + 2 \times 3 = 3 \times 3 - 8
   $$
3. 代入第2式 ($3 = 11 - 1 \times 8$)：
   $$
   1 = 3 \times (11 - 8) - 8 = 3 \times 11 - 3 \times 8 - 8 = 3 \times 11 - 4 \times 8
   $$
4. 代入第1式 ($8 = 96 - 8 \times 11$)：
   $$
   1 = 3 \times 11 - 4 \times (96 - 8 \times 11) =  35 \times 11 - 4 \times 96
   $$

##### 结论

$$
35 \times 11 \equiv 1 \pmod{96}
$$

私钥 $d = 35$。

#### 2. 第二题解答：

我们需要计算 $c \equiv 5^{11} \pmod{119}$。

##### 步骤1：指数二进制化

$e = 11$，其二进制为 **1011** ($8 + 2 + 1$)。
这意味着 $c \equiv 5^8 \times 5^2 \times 5^1 \pmod{119}$。

##### 步骤2：模重复平方法 (Square and Mod)

我们需要依次计算 $m^1, m^2, m^4, m^8 \pmod{119}$。

| 指数幂次 | 计算过程 (上一步结果的平方) | 取模结果 (mod 119)                                  | 备注   |
| -------- | --------------------------- | --------------------------------------------------- | ------ |
| $5^1$  | -                           | **5**                                         | (需要) |
| $5^2$  | $25$                      | **25**                                        | (需要) |
| $5^4$  | $25^2 = 625$              | $625 = 5 \times 119 + 30 \Rightarrow \mathbf{30}$ |        |
| $5^8$  | $30^2 = 900$              | $900 = 7 \times 119 + 67 \Rightarrow \mathbf{67}$ | (需要) |

##### 步骤三：组合相乘

根据二进制 $1011$，选取 $5^8, 5^2, 5^1$：

$$
c\equiv 67 \times 25 \times 5 \pmod{119}$$1. 先算 $25 \times 5 = 125$
   $$125 \pmod{119} = 6
$$

1. 再算 $67 \times 6$:

   $$
   67 \times 6 = 402
   $$
2. 最后取模：

   $$
   402 \div 119 = 3 \dots 45
   $$

   *(验证： $3 \times 119 = 357$ ,  $402 - 357 = 45$)*

##### 结论

加密后的密文 $c = 45$。

---

## 重要辨析：

### 加密模式&计网 5 层体系的加密方式总结

#### 概述：

* **端到端加密 (E2E)** ：
  * **定义** ：数据在源端系统（进程或主机）加密，仅在目的端系统解密。
  * **特征** ：中间节点（路由器、交换机、ISP）只能处理头部路由信息，无法窥探载荷（Payload）。
  * **范围** ：应用层、传输层。
* **链路加密 (Link Encryption)** ：
  * **定义** ：数据在物理链路的每一跳（Hop）或虚拟链路的两端（Gateway）独立加密/解密。
  * **特征** ：中间节点必须拥有密钥，执行 `解密 -> 路由 -> 再加密` 的过程。
  * **范围** ：数据链路层、物理层。

#### 加密方式分类表

| **层次**                         | **典型协议**                            | **加密策略 (拓扑)**           | **执行实体 (谁负责加密)**    | **对上层数据的处理**                 | **封装后的逻辑结构**              | **信任边界 (严谨定义)**                                                                   |
| -------------------------------------- | --------------------------------------------- | ----------------------------------- | ---------------------------------- | ------------------------------------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **应用层**                       | PGP, S/MIME                                   | **端到端**(用户到用户)        | **应用程序**(用户态软件)     | **加密**消息体 + 签名                | `[应用头(可选)][{消息体}]`            | **仅信任应用自身**<br />边界在软件内存。若应用有漏洞或OS被攻破，密文在生成前即泄露。      |
| **传输层之上；<br />应用层之下** | TLS/SSL,SSH                                   | **端到端**(进程到进程)        | **加密库/进程**(如OpenSSL)   | **加密**应用层流/报文                | `[TCP头][{应用层报文}]`               | **信任主机进程 & OS**<br />边界在Socket接口。一旦跨越此边界（如被注入），属系统安全问题。 |
| **网络层**                       | **IPsec-AH**(传输模式)                  | **端到端**(主机到主机)        | **OS 内核**(网络协议栈)      | **认证**传输层段( **不加密** ) | `[原IP头][AH][<TCP/UDP段>]`           | **信任主机 OS 内核**<br />边界在网卡驱动之上。此时数据在OS内部是明文。                    |
| **网络层**                       | **IPsec-ESP**(传输模式)                 | **端到端**(主机到主机)        | **OS 内核**(网络协议栈)      | **加密**+**认证**传输层段      | `[原IP头][ESP头][{TCP/UDP段}][ESP尾]` | **信任主机 OS 内核**<br />同上。                                                          |
| **网络层**                       | **IPsec**(AH/ESP)( **隧道模式** ) | **虚拟链路**(网关到网关)      | **VPN 网关**(OS或专用硬件)   | 鉴别（且加密）整个原IP包                   | `[新IP头][ESP头][{原IP包}][ESP尾]`    | **信任 VPN 网关设备**<br />对内网主机透明。边界在网关内部，若网关被攻破，全网流量可见。   |
| **链路层**                       | WPA2/3, MACsec                                | **物理链路**(逐跳 Hop-by-Hop) | **网卡/基带芯片**(固件/硬件) | **加密**网络层包                     | `[MAC头][{IP数据包}][FCS]`            | **信任每一跳设备**<br />边界在物理设备。中间设备(如AP)必须解密才能交换/路由。             |
| **物理层**                       | 军用专线, 量子加密                            | **物理链路**(逐跳)            | **物理线路/中继器**          | **加密**比特流                       | `[{编码后的比特流}]`                  | **信任物理设施**<br />需拥有对物理线路的绝对控制权。                                      |

> **符号说明** ：`{ }` 表示加密（机密性）；`< >` 表示认证（完整性，但明文）；`[ ]` 表示协议单元边界。
>
> **TLS 的特殊地位** ：
>
> * 尽管带 "Transport" 字样，但它不属于 OS 内核的 TCP/IP 栈。
> * 它位于 **应用层 (HTTP)** 和 **传输层 (TCP)** 之间。应用程序通过库函数（如 `SSL_write`）调用它，它再将加密后的数据交给 TCP (`socket send`)。因此， **信任边界始于应用进程，终于内核 Socket** 。

#### 细节解析

##### 1. 数据状态与中间系统安全性

* **链路加密** ：
  * **状态** ：线路上传输是密文，但 **在中间节点（路由器/交换机）内部是明文** 。
  * **隐患** ：所有中间节点必须是可信的。如果攻击者控制了一台核心路由器，他可以看到所有流经的明文数据。
* **端到端加密** ：
  * **状态** ：线路上传输是密文， **在中间节点内部依然是密文** 。
  * **优势** ：中间网络设施被视为“不可信通道”。路由器只负责搬运“保险箱”，无法打开它。

##### 2. 用户角色与透明度

* **链路加密** ：
  * **对用户透明** ：作为用户，你连接 WiFi 时并不知道（也不需要操作）底层是否使用了 WPA2 加密，这是基础设施自动完成的。
  * **所有消息一视同仁** ：一旦链路加密开启，该链路上的所有流量（HTTP, FTP, DNS）都被强制加密。
* **端到端加密** ：
  * **用户/应用主导** ：通常由用户（选择使用 PGP）或应用程序（开发者决定使用 HTTPS）发起。
  * **粒度精细** ：用户可以选择只加密敏感数据（如密码），而不加密公开数据。

##### 3. 密钥管理与实现

* **链路加密** ：
  * **密钥数量爆炸** ：每两个相邻节点需要一对密钥。
  * **实现** ：通常由 **硬件** （网卡芯片）或底层固件实现，速度极快。
* **端到端加密** ：
  * **密钥独立** ：每对通信用户仅需协商他们自己的密钥，与网络路径无关。
  * **实现** ：通常由 **软件** （OS 内核或应用库）实现。

#### 对比表格

| **维度**          | **链路加密 (Link Encryption)**                                              | **端到端加密 (End-to-End Encryption, E2E)**                                       |
| ----------------------- | --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **1. 拓扑与边界** | **Hop-by-Hop (逐跳)**                                                       | **Source-to-Destination (源到宿)**                                                |
| *定义*                | 数据在每一段物理/逻辑链路上独立加密，在每一个中间节点（路由器/交换机）解密。      | 数据在源头加密，在穿越所有中间网络设施时保持密文，仅在最终目的地解密。                  |
| *保护范围*            | 点到点（Node-to-Node）。保护的是“管道”的每一截。                                | 端到端（User-to-User / Process-to-Process）。保护的是“数据本身”。                     |
| **2. 数据可见性** | **中间节点可见明文**                                                        | **中间节点不可见 (Blind)**                                                        |
| *节点行为*            | 中间节点必须拥有密钥，执行 `解密 -> 路由查看 -> 再加密`的过程。                 | 中间节点只看头部（Header）进行路由，无法解读负载（Payload）。                           |
| *弱点*                | **节点是攻击面** 。如果中间路由器被攻破或被管理员监听，数据即泄露。         | **端点是攻击面** 。只有发送者和接收者的设备（或软件）受控时才安全。               |
| **3. 实现与控制** | **低层、透明、基础设施化**                                                  | **高层、灵活、用户主导**                                                          |
| *透明性*              | **完全透明** 。上层协议（IP/TCP）和用户不知道链路被加密了（如 WiFi WPA2）。 | **不透明/半透明** 。通常由应用程序（如 Signal, PGP）或操作系统（IPsec）显式发起。 |
| *密钥管理*            | **简单但多** 。每对相邻节点需要共享密钥。全网需维护$N$对链路密钥。        | **复杂但独立** 。密钥协商仅在通信双方进行，与网络设施无关（如 Diffie-Hellman）。  |

---

## 快速记忆概念

### 1.Blowfish vs RC5 比较表

| **维度**     | **Blowfish (河豚)**    | **RC5 (变形金刚)**           |
| ------------------ | ---------------------------- | ---------------------------------- |
| **设计者**   | **B**ruce Schneier     | **R**on Rivest               |
| **杀手锏**   | **极致的速度**+ 小内存 | **高度灵活性**(参数化)       |
| **核心操作** | S-Box 查表 + 异或            | **数据相关的循环移位**       |
| **可变性**   | 仅密钥长度可变               | **字长、轮数、密钥**全由你定 |
| **应用场景** | 密码存储 (bcrypt)、嵌入式    | 学术研究、特定硬件架构适配         |
