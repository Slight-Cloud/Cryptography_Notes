# **第十一章 Web安全学习笔记**

## **一、 WEB安全概述**

### **1.1 Web安全的独特性与挑战**

Web作为互联网上最基础、最广泛的客户端/服务器应用，其安全性不仅涵盖了所有传统的计算机与网络安全问题，还面临着一系列独特的挑战：

* **双向交互性与暴露面**：Web服务器需要持续响应来自全球互联网的请求，使其成为一个天然的、持续暴露的攻击目标。  
* **软件的复杂性**：现代Web应用（包括浏览器、Web服务器软件、内容管理系统等）的代码极其复杂，这种复杂性很容易隐藏未被发现的安全漏洞。  
* **系统核心地位**：Web服务器通常是企业或机构信息系统的“门户”，一旦被攻破，攻击者可能以此为跳板，渗透至整个内部网络，造成灾难性后果。  
* **用户的非专业性**：绝大多数Web用户是未经专业安全训练的普通人，他们普遍缺乏安全意识和有效的防护工具，容易成为攻击的突破口。

### **1.2 Web安全的层次化方法**

针对Web的安全防护可以在网络协议栈的不同层次实施：

* **网络层安全**：主要通过 **IPSec** 协议实现，为IP数据包提供加密和认证，对上层应用透明。  
* **传输层安全**：在传输控制协议（TCP）之上，通过 **SSL/TLS** 协议建立一个安全的通道，为上层应用（如HTTP, FTP）提供端到端的安全服务。  
* **应用层安全**：针对特定的应用程序设计安全机制，例如为电子商务设计的 **SET (安全电子交易)** 协议。

## **二、 SSL/TLS 协议详解**

SSL (Secure Sockets Layer) 及其后续标准 TLS (Transport Layer Security) 是为网络通信提供安全及数据完整性的一种安全协议。我们日常所见的 https:// 网址，其安全基础就是SSL/TLS。

### **2.1 SSL/TLS 体系结构**

SSL/TLS 协议**位于TCP层之上、应用层之下**，主要由两个子协议组成：

1. **SSL/TLS 记录协议 (Record Protocol)**：负责对上层应用数据进行封装、加密和传输。  
2. **SSL/TLS 握手协议 (Handshake Protocol)**：负责在客户端和服务器之间进行身份认证、协商加密算法和生成会- 密钥。

此外，还有两个辅助协议：告警协议 (Alert Protocol) 用于传递错误信息，修改密码规范协议 (Change Cipher Spec Protocol) 用于通知对方开始使用新协商的密钥。

### **2.2 SSL 连接 (Connection) 与会话 (Session)**

* **会话 (Session)**：客户端与服务器之间的一种关联，通过一次完整的握手协议创建。一个会话定义了一组共享的安全参数（如会话密钥、加密套件等）。建立会话的成本较高。  
* **连接 (Connection)**：一个具体的、点对点的网络传输链路。多个连接可以关联到同一个会话，从而**复用**已协商好的安全参数，避免了为每个连接都进行昂贵的握手协商过程，提高了效率。

### **2.3 SSL/TLS 记录协议的操作流程**

当应用层数据（如一个HTTP请求）递交给记录协议后，会经过以下步骤处理：

1. **分片 (Fragmentation)**：将上层数据分割成不大于 16KB (2^14 字节) 的数据块。  
2. **压缩 (Compression)**：对分片后的数据进行压缩（可选步骤），必须使用无损压缩算法。  
3. **计算消息认证码 (MAC)**：使用握手协议协商好的MAC算法和密钥，为“压缩后的数据 \+ 序列号”计算MAC值，并附加在数据后面，以保证数据完整性。  
4. **加密 (Encryption)**：使用握手协议协商好的对称加密算法和会话密钥，对“压缩后的数据 \+ MAC”进行加密。  
5. **封装 (Append Header)**：为加密后的数据块添加一个SSL记录头，包含内容类型、协议版本、数据长度等信息，形成最终的SSL记录单元，发送到TCP层进行传输。

### **2.4 SSL/TLS 握手协议的流程 (核心)**

握手协议是SSL/TLS中最关键、最复杂的部分，其**目标是让客户端和服务器在不安全的信道上安全地完成身份认证和密钥协商**。

**主要阶段：**

1. **第一阶段：交换Hello消息，建立安全能力**  
   * ClientHello: 客户端向服务器发送其支持的SSL/TLS版本、一个客户端随机数 R\_c、支持的加密算法套件列表。  
     客户端 \-\> 服务器: Version, R\_c, CipherSuites  
   * ServerHello: 服务器从客户端列表中选择一个加密套件，并发送自己的SSL/TLS版本、一个服务器随机数 R\_s。  
     服务器 \-\> 客户端: Version, R\_s, Selected\_CipherSuite  
2. **第二阶段：服务器认证与密钥交换**  
   * Certificate: 服务器发送自己的X.509数字证书 Cert\_s，其中包含了服务器的公钥 KU\_s。  
     服务器 \-\> 客户端: Cert\_s  
   * ServerKeyExchange (可选): 如果证书中的公钥不足以进行密钥交换（如用于签名的DSS密钥），服务器需发送此消息提供额外的密钥交换参数。  
   * CertificateRequest (可选): 如果服务器需要验证客户端身份，会发送此消息请求客户端证书。  
   * ServerHelloDone: 服务器告知客户端，自己的Hello消息已发送完毕。  
3. **第三阶段：客户端认证与密钥交换**  
   * 客户端验证服务器证书 Cert\_s 的有效性（例如，检查签名和有效期）。  
   * ClientKeyExchange: 客户端生成一个预主密钥 (Pre-master Secret, PMS)，并用服务器的公钥 KU\_s 加密后发送给服务器。这是密钥交换的核心步骤。  
     客户端 \-\> 服务器: E(KU\_s, PMS)  
     服务器收到后用自己的私钥 KR\_s 解密即可得到PMS: D(KR\_s, E(KU\_s, PMS)) \= PMS  
   * Certificate & CertificateVerify (可选): 如果服务器请求了客户端认证，客户端会发送自己的证书 Cert\_c（包含公钥 KU\_c），并用自己的私钥 KR\_c 对到目前为止所有握手消息的哈希值进行签名，发送给服务器以证明自己拥有该私钥。  
     客户端 \-\> 服务器: Cert\_c, Sign(KR\_c, H(HandshakeMessages))  
4. **第四阶段：结束握手**  
   * 客户端和服务器使用相同的三个随机数（R\_c, R\_s）和预主密钥（PMS）通过一个伪随机函数 (PRF) 各自独立地计算出完全相同的“主密钥 (Master Secret, MS)”。  
     MS \= PRF(PMS, "master secret", R\_c \+ R\_s)  
   * 再由主密钥派生出一系列用于加密和MAC计算的会话密钥 (Session Keys)。  
     SessionKeys \= PRF(MS, "key expansion", R\_s \+ R\_c)  
   * ChangeCipherSpec: 客户端/服务器发送此消息，通知对方自己准备好切换到加密通信模式。  
   * Finished: 客户端/服务器将之前所有握手消息的哈希值用新生成的会话密钥加密后发送给对方。这是对整个握手过程的最终校验，如果双方都能正确解密并验证对方的Finished消息，则证明握手成功。

至此，安全的加密通道建立完毕，双方开始使用会话密钥通过记录协议进行加密通信。

## **三、 安全电子交易 (SET) 协议**

SET 是由 Visa 和 Mastercard 联合多家科技公司于1996年推出的，专门为互联网上的信用卡支付设计的开放性安全规范。它本身不是支付系统，而是一套定义了交易各方如何安全通信的安全协议和消息格式。

### **3.1 SET 交易的参与方**

* **持卡人 (Cardholder)**: 消费者。  
* **商家 (Merchant)**: 在线销售商品或服务的店铺。  
* **发卡行 (Issuer)**: 为持卡人发行信用卡的银行。  
* **收单行 (Acquirer)**: 处理商家信用卡交易的银行。  
* **支付网关 (Payment Gateway)**: 收单行或其代理提供的，负责将互联网上的SET消息格式转换成银行内部网络能处理的格式的设备/服务。  
* **认证中心 (CA)**: 负责为所有参与方签发数字证书，建立信任链。

### **3.2 双重签名 (Dual Signature) \- SET 的核心技术**

为了实现隐私保护目标，SET 创造性地使用了双重签名技术。

**构造过程：**

1. 持卡人的客户端软件准备两份信息：  
   * **订单信息 (OI \- Order Information)**：包含商品、数量、价格等，将发给商家。  
   * **支付信息 (PI \- Payment Information)**：包含信用卡号、有效期等，将通过商家转发给支付网关/银行。  
2. 分别计算 OI 和 PI 的消息摘要（哈希值）：  
   * OIMD \= H(OI)  
   * PIMD \= H(PI)  
3. 将这两个摘要拼接在一起，再次计算哈希值：  
   * POMD \= H(PIMD || OIMD)  
4. 持卡人用自己的**签名私钥**对 POMD 进行加密（签名），得到的结果就是**双重签名 DS**。  
   * DS \= E(KR\_c, POMD) (其中 KR\_c 是持卡人私钥)

**验证与信息隔离：**

* **持卡人发送给商家**：OI, DS, PIMD (注意，不是PI本身)。  
  * 商家拥有 OI 和 PIMD，可以本地计算 H(PIMD || H(OI))，然后用持卡人的公钥解密 DS，比较二者是否相等。  
  * 如果相等，则证明这份订单和一份支付指令被同一个人绑定在了一起。但商家无法从 PIMD 中反推出 PI（信用信息）。  
* **商家转发给支付网关**：PI (由持卡人加密后提供), DS, OIMD。  
  * 支付网关拥有 PI 和 OIMD，可以本地计算 H(H(PI) || OIMD)，然后用持卡人的公钥解密 DS 进行验证。  
  * 支付网关可以确认支付信息的有效性，但无法从 OIMD 中反推出 OI（购物详情）。

通过这种方式，SET 巧妙地实现了交易数据在商家和银行之间的隔离，提供了比通用SSL/TLS更强的、针对支付场景的隐私保护。

### **3.3 SET 交易流程 (Transaction Flow)**

一个完整的SET交易主要包含以下三个阶段：

#### **1\. 购买请求 (Purchase Request)**

这是交易的开始，由持卡人发起，主要完成订单和支付信息的准备与安全发送。

1. **初始化与证书交换**: 持卡人向商家请求其签名证书和支付网关的密钥交换证书。商家返回这些证书，并附上本次交易的唯一ID。  
2. **证书验证**: 持卡人客户端验证商家和支付网关证书的有效性。  
3. **消息准备**: 持卡人客户端生成订单信息(OI)和支付信息(PI)。  
4. **密钥生成**: 生成一个一次性对称密钥 Ks。  
5. **双重签名**: 按照3.2节所述，生成双重签名 DS。  
6. **加密与打包**:  
   * **为支付网关准备**: 将 PI 和 DS 等支付相关信息用对称密钥 Ks 加密。然后用支付网关的公钥加密 Ks，形成一个**数字信封**。  
   * **为商家准备**: 将 OI、DS 和 PIMD 打包。  
7. **发送请求**: 持卡人将上述为商家和支付网关准备的两组信息，连同自己的证书，一同发送给商家。

#### **2\. 支付认证 (Payment Authorization)**

商家收到请求后，需要向支付网关请求授权，确认该笔交易是否有效。

1. **商家处理**:  
   * 商家验证持卡人的证书。  
   * 商家使用持卡人的公钥和收到的 PIMD 来验证双重签名 DS 的有效性，以确认订单的完整性。  
   * 商家处理订单 OI，并将支付相关部分（加密的PI、数字信封、OIMD等）转发给支付网关，请求支付授权。  
2. **支付网关处理**:  
   * 支付网关验证商家和持卡人的证书。  
   * 用自己的私钥打开数字信封，获得对称密钥 Ks。  
   * 用 Ks 解密支付信息，得到 PI 和 DS。  
   * 使用持卡人的公钥和收到的 OIMD 验证双重签名 DS。  
   * （核心步骤）支付网关联系发卡行，对 PI 进行真实性和信用额度的认证。  
3. **认证响应**: 支付网关将发卡行的认证结果（批准或拒绝）返回给商家。商家再将结果通知持卡人。如果批准，商家就可以提供商品或服务。

#### **3\. 资金获取 (Payment Capture)**

在交易完成后（例如商品已发货），商家向支付网关发起请求，以获取这笔交易的款项。

1. **获取请求**: 商家向支付网关发送“获取请求”消息，其中包含交易ID和授权信息。  
2. **资金清算**: 支付网关处理该请求，并通过银行网络完成商家、收单行和发卡行之间的资金清算。  
3. **获取应答**: 支付网关将处理结果返回给商家，确认款项已经划拨。

### **3.4 SET 的主要特性、目标与实现方式**

* **信息机密性**：确保持卡人的账号和支付信息在传输过程中是加密的。  
* **数据完整性**：保证所有交易数据在传输中不被篡改。  
* **身份认证：**  
  * **持卡人身份认证**：让商家可以验证用户是信用卡合法持有者。  
  * **商家身份认证**：让持卡人可以验证商家的合法性。  
* **隐私保护**：这是SET的核心设计之一。确保交易信息只提供给需要它的那一方。即**商家看不到用户的信用卡号，银行看不到用户的购物清单**。

#### **功能实现方式**

* **信息机密性**：通过**数字信封 (Digital Envelope)** 技术实现。  
  * 敏感数据（如支付信息PI）本身是用一个随机生成的**对称密钥**进行加密的，以保证效率；  
  * 然后，这个对称密钥再用接收方（如支付网关）的**公钥**进行加密。这样既保证了加密速度，又保证了密钥传输的安全性。  
* **数据完整性**：通过**哈希函数**（如SHA-1）和**数字签名**实现。  
  * 对消息计算哈希值（摘要），然后对摘要进行签名，可以有效防止数据在传输过程中被篡改。  
* **身份认证**：通过 **X.509 数字证书**和**数字签名**实现。  
  * SET体系中的所有参与方（持卡人、商家、支付网关）都必须拥有由受信任的CA颁发的数字证书。在交易过程中，各方通过交换证书并验证对方的数字签名来确认彼此的真实身份。  
* **隐私保护**：通过核心的**双重签名 (Dual Signature)** 技术实现。  
  * 双重签名将订单信息(OI)和支付信息(PI)在密码学上绑定，但又巧妙地将二者隔离开，使得商家只能验证与订单相关的部分，而支付网关只能验证与支付相关的部分，从而实现了信息的按需访问，保护了用户隐私。