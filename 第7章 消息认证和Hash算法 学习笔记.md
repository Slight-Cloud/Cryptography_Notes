# **第七章学习笔记：消息认证与Hash算法**

## **第一部分：消息认证导论 (Message Authentication)**

### **1\. 为什么需要消息认证？**

信息安全旨在保护信息资源免受各种威胁，其核心需求包括 ：

* **保密性 (Confidentiality)**: 防止信息被未经授权的个体获取 。  
* **完整性 (Integrity)**: 确保数据在传输或存储过程中未被篡改或损坏 。  
* **可用性 (Availability)**: 确保授权用户在需要时可以访问信息及相关资产 。  
* **认证 (Authenticity)**: 验证通信实体（用户、系统、信息等）身份的真实性 。  
* **不可否认性 (Non-repudiation)**: 防止通信的发送方或接收方否认其行为 。

当你通过网络进行一次在线交易时，系统需要确保两件关键的事情：

* **“这条交易指令真的是由合法的账户持有人发出的吗？”**  
  * —— 这就是**认证 (Authenticity)**，确认消息来源是真实的，而不是攻击者伪造的。  
* **“交易金额、收款账户等信息在传输过程中被修改过吗？”**  
  * —— 这就是**完整性 (Integrity)**，确保数据在从客户端到服务器的过程中没有被篡改。

消息认证就是为了解决这两个核心问题。在数字世界里，所有的数据都可能被拦截、伪造或修改，因此我们需要一种机制来验证信息的“真伪”和“完整”。

### **2\. 常见的网络攻击与应对策略**

| 攻击类型 | 技术应用实例 | 技术世界的对策 |
| :---- | :---- | :---- |
| **泄密（通信内容被窃取）** | 未加密的电子邮件或即时消息在公共Wi-Fi下被抓包窃听。 | **加密 (Encryption)** |
| **伪装（攻击者伪装为合法用户发送消息）** | 收到一封伪装成银行官方的钓鱼邮件，要求你输入密码。 | **消息认证 (Message Authentication)** |
| **内容篡改（消息内容被修改）** | 在一次在线支付请求中，攻击者通过中间人攻击将支付金额从10元修改为1000元。 | **消息认证 (Message Authentication)** |
| **否认（发送方/接收方否认发送/接收过消息）** | 用户完成了一次在线购买后，向平台声称“我从未授权过这笔交易”。 | **数字签名 (Digital Signature)** |

##### **3\. 什么是消息认证？**

消息认证是一个验证消息来源真实性和内容完整性的过程 。其目标是确保 ：

* 接收者可以**证实消息的合法性、真实性和完整性** 。  
* 通信双方**不能抵赖**其行为 。  
* 除合法发送者外，**任何第三方都无法伪造消息**

## **第二部分：实现消息认证的三种核心方式**

### **方式一：消息加密 (Message Encryption)**

利用加密算法，将消息本身变成“认证凭证”。

#### **1\. 对称加密**

通信双方（比如客户端和服务器）共享同一个密钥。

* **如何认证**：服务器收到一段密文，如果它能用共享密钥成功解密并解析出符合协议格式的数据包，它就能确认这个数据包一定是来自合法的客户端。因为除了它们俩，没有第三方知道这个密钥。  
* **实例**：在某些VPN（虚拟私人网络）连接中，客户端和服务器会使用预共享密钥（PSK）。客户端发送的所有数据都用此密钥加密，服务器解密成功即可验证其来源。  
* **缺点**：**无法防止抵赖**。因为密钥是共享的，服务器也可以用这个密钥伪造一份“来自客户端的”加密数据。因此，无法作为法律上不可否认的证据。

#### **2\. 公钥加密（非对称加密）**

每个人都有一对密钥：公钥（公开）和私钥（保密）。

* **场景A：只求保密，不为认证**  
  * **做法**：客户端用**服务器的公钥**来加密要发送的敏感数据。  
  * **效果**：只有服务器能用它的私钥解密。这保证了数据传输的机密性。  
  * **实例**：你在浏览器中访问HTTPS网站时，浏览器会用网站的公钥加密你们之间通信用的对称密钥，确保只有网站服务器能解密得到它。  
* **场景B：只为认证和签名，不怕泄密**  
  * **做法**：发送方Alice用**她自己的私钥**来加密数据的哈希值（即数字签名）。  
  * **效果**：任何人都可以用Alice的公钥来解密并验证签名。如果能成功，就证明这条消息确实是Alice签署的，且内容未被篡改。  
  * **实例**：发布操作系统更新补丁时，软件公司会用其私钥对补丁文件的哈希值进行签名。你的操作系统在安装更新前，会用内置的公司公钥来验证签名，确保补丁是官方发布的，而不是病毒。  
* **场景C：既要保密，又要认证和签名**  
  * **做法（混合加密）**：Alice先用**自己的私钥**对数据摘要进行签名，然后生成一个临时的对称密钥，用它加密原始数据，最后用**Bob的公钥**加密这个临时的对称密钥。  
  * **效果**：这是最常见的安全通信方式（如PGP邮件加密），确保了消息只有Bob能看，并且Bob能确认这消息就是Alice发的。

### **方式二：消息认证码 (MAC \- Message Authentication Code)**

MAC是一种基于密钥的哈希算法，用于验证消息的完整性和真实性。

* **工作原理**：它将**消息内容**和一个**共享密钥**输入到一个算法（如HMAC-SHA256）中，生成一个固定长度的认证码。这个认证码会附加在原始消息后面一起发送。  
* **如何认证**：接收方收到消息后，用同样的消息内容和共享密钥，通过同一个算法，重新计算一次MAC。如果计算出的MAC和收到的MAC完全一致，就证明消息未被篡改，且来自持有同一密钥的对方。  
* **实例：API接口安全**  
  1. 一个Web应用需要调用一个支付服务的API。双方约定了一个共享密钥。  
  2. Web应用发送请求，请求体包含“{user\_id: 123, amount: 100}”。  
  3. 它用请求体和共享密钥生成一个HMAC值，如“a1b2c3d4”，并将其放在请求头中发送。  
  4. 支付服务收到请求后，用同样的逻辑计算请求体的HMAC值。  
  5. 如果计算结果与请求头中的“a1b2c3d4”一致，则处理该请求。否则，拒绝请求，因为这表明数据可能被篡改或请求是伪造的。

### **方式三：散列函数 (Hash Function)**

散列函数是一种能为任何数据生成一个固定长度“数字指纹”（消息摘要）的算法。

* **核心特点**：  
  * **无需密钥**：任何人都可以对同一份数据计算出相同的哈希值。  
  * **固定长度**：无论输入文件多大，输出的哈希值长度都是固定的（例如MD5是128位，SHA256是256位）。  
  * **单向性**：无法通过哈希值反推出原始数据。  
  * **高度敏感**：原始数据哪怕只修改一个比特，计算出的哈希值也会面目全非。  
* **实例：验证文件下载的完整性**  
  1. 开源软件项目（如Ubuntu Linux）在官网上发布ISO镜像文件的下载链接。  
  2. 在下载链接旁边，他们会同时公布这个ISO文件对应的SHA256哈希值。  
  3. 你通过某个镜像站下载了这个ISO文件。  
  4. 下载完成后，你在自己的电脑上使用工具（如sha256sum）计算下载文件的SHA256值。  
  5. 比较你计算出的哈希值和官网公布的哈希值。如果完全一样，证明你下载的文件是完整且未经篡改的官方原版。如果不一样，说明文件已损坏或被植入恶意代码，应立即删除。

## **第三部分：Hash算法详解 —— MD5**

MD5是曾经最流行的哈希算法之一，虽然现在因安全问题已被淘汰，但了解其原理对学习密码学非常有帮助。

* **目标**：将**任意长度**的数据，转换成一个**128位**的固定长度指纹。

### **MD5的工作流程**

#### **工作流程总结**

MD5算法可以看作一个高度标准化的“数据处理流水线”，它通过以下五个步骤将任意输入数据转换为一个128位的哈希值：

1. **附加填充位**：对原始数据进行填充，使其长度满足特定要求，为下一步附加长度信息做准备。  
2. **附加原始长度**：在填充后的数据末尾记录原始数据的真实长度，使得最终的数据可以被完美地切割成512位的整数倍块。  
3. **初始化MD缓冲区**：设置四个固定的32位寄存器作为计算的起始点。  
4. **循环处理数据块**：使用一个复杂的压缩函数，将每个512位的数据块与寄存器的当前值进行混合计算，并更新寄存器的值。  
5. **输出结果**：所有数据块处理完毕后，将四个寄存器的最终值拼接起来，形成最终的128位MD5哈希值。

#### **各流程详解（以计算"cat"的MD5值为例）**

我们将以计算ASCII字符串 "cat" 的MD5值为例，来详细拆解每一步。

**原始数据**: "cat"

* **ASCII码**: 01100011 01100001 01110100  
* **原始长度**: 3字节 \= 24比特

**第一步：附加填充位 (Padding)**

* **详细说明**：MD5要求处理的数据长度必须是512位的整数倍。为了满足这个要求，需要对原始数据进行填充。规则是：先在数据末尾附加一个比特“1”，然后持续附加比特“0”，直到总长度满足(512 \* N) \+ 448位（其中N是自然数）。  
* **实例 ("cat")**：  
  1. 原始24比特数据: 01100011 01100001 01110100  
  2. 在其末尾附加一个比特“1”。现在总长度是25比特。  
  3. 目标长度是448比特，所以需要再附加 448 \- 25 \= 423 个“0”。  
  4. **本步结果**：我们得到了一个448比特长的数据块，由\["cat"的24比特\] \+ \[1个比特'1'\] \+ \[423个比特'0'\]组成。

**第二步：附加原始长度**

* **详细说明**：在填充后的数据末尾，需要附加一个64位的数据块，用来记录**原始数据**在填充前的长度（单位：比特）。这确保了即使两个不同的消息填充后变得一样，它们的哈希值也不同，因为其原始长度不同。  
* **实例 ("cat")**：  
  1. "cat"的原始长度是24比特。  
  2. 将数字24转换为64位的二进制数（MD5规范要求使用小端序存储）。  
  3. 将这个64位的长度块附加到第一步生成的448比特数据块之后。  
  4. **本步结果**：448比特（填充后数据） \+ 64比特（长度） \= 512比特。我们得到了一个完整的512位消息块，准备进入核心计算环节。如果原始消息很长，这里可能会生成多个512位的消息块。

**第三步：初始化MD缓冲区 (Initialize MD Buffer)**

* **详细说明**：MD5内部有一个128位的缓冲区，它由四个32位的寄存器（通常称为A, B, C, D）组成。在计算开始前，这四个寄存器被赋予固定的十六进制初始值，这些值是精心挑选的，常被称为“魔术数”。  
* **实例**：  
  * A \= 0x67452301  
  * B \= 0xEFCDAB89  
  * C \= 0x98BADCFE  
  * D \= 0x10325476

**第四步：循环处理数据块（压缩函数）**

* **详细说明**：这是MD5算法的核心，也是最复杂的部分。它将当前的128位哈希值（A,B,C,D寄存器）与一个512位的消息块进行“混合”，生成一个新的128位哈希值。这个过程包含以下关键元素：  
  * **四轮运算**：整个压缩过程分为4轮，每轮进行16次操作，总共64步。  
  * **四个非线性函数**：每一轮使用一个不同的逻辑函数（F, G, H, I）来增加计算的复杂性。  
    * **F(B,C,D) \= (B & C) | (\~B & D)**  
    * **G(B,C,D) \= (B & D) | (C & \~D)**  
    * **H(B,C,D) \= B ^ C ^ D**  
    * I(B,C,D) \= C ^ (B | \~D)  
      （其中 & 是按位与, | 是按位或, \~ 是按位非, ^ 是按位异或）  
  * **消息子分组 M\[k\]**：512位的消息块被分为16个32位的子块，在64步运算中以不同的顺序使用。  
  * **常量 T\[i\]**：64个预先计算好的32位常量，由正弦函数生成，用于消除计算中的规律性。  
  * **主循环公式**：每一步操作都遵循一个核心公式，然后将寄存器A,B,C,D的值进行循环右移。  
* **实例 ("cat")**：  
  1. **准备阶段**：  
     * 将初始化的A, B, C, D值复制一份（记为AA, BB, CC, DD）。  
     * 将我们生成的512位消息块分为16个32位的子块M\[0\]到M\[15\]。  
  2. **执行64步运算**：  
     * **第1步 (Round 1\)**:  
       * 使用F函数, 消息子块M\[0\], 常量T\[1\], 和一个特定的循环左移位数s。  
       * 计算 temp \= F(B,C,D) \+ A \+ M\[0\] \+ T\[1\]。  
       * 将temp循环左移s位，然后加上B，结果存回A。  
       * 最后，将(D, A, B, C)赋值给(A, B, C, D)完成一次轮转。  
     * **第2步到第16步**: 重复上述过程，但使用不同的M\[k\], T\[i\]和s值。  
     * **第17步 (Round 2\)**: 开始使用G函数，并按新的顺序使用消息子块。  
     * ...依此类推，直到64步全部完成。  
  3. **更新哈希值**：  
     * 将计算了64步后得到的A, B, C, D，与开始时保存的副本AA, BB, CC, DD进行模加：  
       * A \= AA \+ A  
       * B \= BB \+ B  
       * C \= CC \+ C  
       * D \= DD \+ D  
     * 这个结果就是处理完当前消息块后的新哈希值（新的A,B,C,D）。因为"cat"只有一个消息块，这个值就是最终哈希值的基础。如果还有下一个消息块，它将作为处理下一个块时的初始A,B,C,D值。

**第五步：输出哈希值**

* **详细说明**：当所有消息块都处理完毕后，将最终的A, B, C, D四个32位寄存器的值（同样，要注意字节序）按顺序拼接在一起，就形成了最终的128位MD5哈希值。  
* **实例 ("cat")**：  
  * **最终MD5值 (十六进制表示)**: d077f244def8a70e5ea758bd8352fcd8

### **MD5为什么不安全了？**

MD5的主要问题是“抗碰撞性”被攻破\*\*。

* **什么是碰撞**：找到两个完全不同的输入数据，它们通过哈希函数计算后能得到完全相同的哈希值。  
* **MD5的问题**：在MD5被设计时，找到一个碰撞被认为是计算上不可行的。但在2004年，王小云教授的团队发现了一种高效的方法，可以在实际可接受的时间内人为地制造出MD5碰撞。  
* **实例**：攻击者可以创建两个不同的程序文件：  
  * 程序A（无害）：一个正常的图片查看器。  
  * 程序B（恶意）：一个在后台安装勒索软件的程序。  
  * 通过精巧地修改两个程序文件中的非执行部分（例如注释或元数据），攻击者可以使这两个完全不同的程序拥有**完全相同的MD5值**。  
  * 软件开发者对无害的程序A进行代码审查，计算其MD5值并进行数字签名。但由于程序B具有相同的MD5值，攻击者可以将开发者的签名附加到恶意程序B上分发。用户验证签名时会显示合法，从而在不知不觉中安装了勒索软件。

**结论**：由于存在严重的碰撞漏洞，MD5**绝对不能再用于任何安全相关的场景**，如密码存储、数字签名、代码完整性校验等。更安全的替代算法是 **SHA-256** 或 **SHA-3** 系列。