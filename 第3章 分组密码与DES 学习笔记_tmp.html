<!DOCTYPE html>
<html>
<head>
<title>第3章 分组密码与DES 学习笔记.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css" type="text/css"><link rel="stylesheet" href="file:///d%3A/code/Notes/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/D/code/.vscode/pdf-style.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8Edes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">第三章 分组密码与DES 学习笔记</h1>
<h2 id="1-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8Efeistel%E5%AF%86%E7%A0%81">1. 分组密码与Feistel密码</h2>
<h3 id="11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-block-cipher">1.1 什么是分组密码 (Block Cipher)？</h3>
<ul>
<li><strong>核心思想</strong>：将要加密的明文消息分割成固定长度的“组”（Block），然后使用同一个密钥对每个组分别进行加密。</li>
<li><strong>过程</strong>：
<ol>
<li><strong>划分</strong>：将明文序列划分为长度为n的组。</li>
<li><strong>加密</strong>：在密钥的控制下，将每个明文组变换成等长的密文组。</li>
</ol>
</li>
<li><strong>本质</strong>：分组密码可以看作是一个非常庞大的、可逆的“代换”操作。对于一个n位的分组，存在 2^(2^n) 种可能的可逆变换。</li>
</ul>
<h3 id="12-%E6%B7%B7%E4%B9%B1-confusion-%E4%B8%8E%E6%89%A9%E6%95%A3-diffusion">1.2 混乱 (Confusion) 与扩散 (Diffusion)</h3>
<p>这是由信息论创始人克劳德·香农（Claude Shannon）提出的设计理想密码系统的两个基本原则：</p>
<ul>
<li><strong>混乱 (Confusion)</strong>：使密文的统计特性与密钥之间的关系尽可能复杂。简单来说，就是让攻击者无法通过分析密文来推断出密钥的任何信息。主要通过“代换”（S盒）来实现。</li>
<li><strong>扩散 (Diffusion)</strong>：将明文的统计结构扩散、打乱到长串的密文中。简单来说，就是让明文中的任何一位变化，都能影响到密文中的许多位。主要通过“置换”（P盒）来实现。</li>
</ul>
<p>现代分组密码的基础就是基于“代换-置换网络”（Substitution-Permutation Network, SPN）来实现混乱和扩散。</p>
<h3 id="13-feistel-%E5%AF%86%E7%A0%81%E7%BB%93%E6%9E%84">1.3 Feistel 密码结构</h3>
<p>这是现代许多对称分组密码（包括DES）所采用的核心结构。</p>
<ul>
<li>
<p><strong>设计思想</strong>：</p>
<ol>
<li>将输入的明文块分成左右两半：L0 和 R0。</li>
<li>进行多轮（Rounds）迭代处理。</li>
<li>在每一轮迭代中，使用一个“轮函数” F 来处理数据。</li>
</ol>
</li>
<li>
<p><strong>加密过程（第 i 轮）</strong>：</p>
<ul>
<li>新的左半部分直接来自上一轮的右半部分：L(i) = R(i-1)</li>
<li>新的右半部分由上一轮的左半部分与轮函数 F 的输出进行异或（XOR）得到：R(i) = L(i-1) XOR F(R(i-1), K(i))</li>
<li>其中 K(i) 是第 i 轮所使用的子密钥。</li>
</ul>
</li>
<li>
<p><strong>Feistel网络单轮加密流程图</strong>:
上一轮输入 (L(i-1), R(i-1))</p>
</li>
</ul>
<pre class="hljs"><code><div>                         +-------------------+
        R(i-1) ---------&gt;|      轮函数 F     |&lt;--- 子密钥 K(i)
                         |   F(R(i-1),K(i))  |
                         +---------+---------+
                                        |
                                        v
L(i-1) ----------------&gt; [  XOR  ] -----------------&gt; R(i)
                                        ^
                                        |
                                    F 输出

L(i) = R(i-1)
R(i) = L(i-1) XOR F(R(i-1), K(i))

本轮输出 (L(i), R(i))
</div></code></pre>
<p>本轮输出 (L(i), R(i))</p>
<ul>
<li>解密过程：
Feistel结构最巧妙的优点在于：无论轮函数 F 多么复杂，加密和解密的过程都非常相似，只需将子密钥按相反的顺序使用即可。这大大简化了硬件实现。</li>
</ul>
<h2 id="2-s-des-%E7%AE%80%E5%8C%96%E7%89%88des">2. S-DES (简化版DES)</h2>
<p>S-DES是一个教学版的DES，它保留了DES的核心思想，但参数规模小得多，便于理解和手动计算。</p>
<ul>
<li><strong>输入</strong>：8位明文，10位密钥。</li>
<li><strong>输出</strong>：8位密文。</li>
<li><strong>结构</strong>：包含初始置换（IP）、两轮复杂的轮函数、一个中间交换（SW）和逆初始置换（IP^-1）。</li>
<li><strong>S-DES 整体加密流程图</strong>:</li>
</ul>
<pre class="hljs"><code><div>  8位明文
  |
  +--------------+
   |   初始置换     |
   |      IP        |
  +--------------+
  | (分成 L0, R0)
  +-------------------+
  |   轮函数 f(K1)    |  &lt;--- K1
  +-------------------+
  | (得到 L1, R1)
  +--------------+
  |     交换 SW    |
  +--------------+
  | (输入 R1, L1)
  +-------------------+
  |   轮函数 f(K2)    |  &lt;--- K2
  +-------------------+
  | (得到 L2, R2)
  +--------------+
   | 逆初始置换     |
   |     IP^-1      |
  +--------------+
  |
  8位密文
</div></code></pre>
<h3 id="21-s-des-%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E8%AF%A6%E8%A7%A3">2.1 S-DES 密钥生成详解</h3>
<p>从10位主密钥 K 生成两个8位的子密钥 K1 和 K2。这个过程本身就是一个迷你的加密过程，目的是打乱和变换原始密钥。</p>
<ol>
<li><strong>P10置换 (Permutation 10)</strong>
<ul>
<li><strong>什么是置换？</strong> 置换就是“重新排列位置”。P10置换表规定了如何将输入的10个比特重新排序(而p8置换同理)。</li>
<li><strong>工作原理</strong>：假设P10置换表是 (3, 5, 2, 7, 4, 10, 1, 9, 8, 6)。这意味着，输出的第1位是输入的第3位，输出的第2位是输入的第5位，以此类推。它只改变位置，不改变比特的值。</li>
</ul>
</li>
<li><strong>分割</strong>
<ul>
<li><strong>工作原理</strong>：将经过P10置换后的10位密钥，简单地从中间分开，变成左、右两个各5位的部分。</li>
</ul>
</li>
<li><strong>生成K1</strong>
<ul>
<li><strong>循环左移1位 (LS-1)</strong>：对分割后的左、右两个5位部分分别执行循环左移1位。</li>
<li><strong>P8置换 (Permutation 8)</strong>：将在上一步移位后合并成的10位密钥中，根据P8置换表，挑选出8位并重新排列，得到第一个子密钥 K1。</li>
</ul>
</li>
<li><strong>生成K2</strong>
<ul>
<li><strong>循环左移2位 (LS-2)</strong>：在生成K1的移位结果的基础上，再对左、右两半分别执行循环左移2位。</li>
<li><strong>P8置换</strong>：将再次移位并合并后的10位密钥，通过同一个P8置换表，生成第二个子密钥 K2。</li>
</ul>
</li>
</ol>
<h4 id="211-%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B">2.1.1 密钥生成实例</h4>
<p>假设主密钥 K = (1010000010)。P10置换表为 (3, 5, 2, 7, 4, 10, 1, 9, 8, 6)P8置换表为 (6, 3, 7, 4, 8, 5, 10, 9)</p>
<ol>
<li><strong>P10置置换</strong>
<ul>
<li>输入 (K): 1 0 1 0 0 0 0 0 1 0 (位置 1 到 10)</li>
<li>输出: 1 0 0 0 0 0 1 1 0 0</li>
</ul>
</li>
<li><strong>分割</strong>
<ul>
<li>输入: 1000001100</li>
<li>左半部分 (L): 10000</li>
<li>右半部分 (R): 01100</li>
</ul>
</li>
<li><strong>生成 K1</strong>
<ul>
<li>循环左移1位 (LS-1):
<ul>
<li>L: 10000 -&gt; 00001</li>
<li>R: 01100 -&gt; 11000</li>
</ul>
</li>
<li>合并: 0000111000</li>
<li>P8置换:
<ul>
<li>输入: 0 0 0 0 1 1 1 0 0 0 (位置 1 到 10)</li>
<li>输出 (K1): 10100100</li>
</ul>
</li>
</ul>
</li>
<li><strong>生成 K2</strong>
<ul>
<li>在LS-1结果上再循环左移2位 (LS-2):
<ul>
<li>L: 00001 -&gt; 00100</li>
<li>R: 11000 -&gt; 00011</li>
</ul>
</li>
<li>合并: 0010000011</li>
<li>P8置换:
<ul>
<li>输入: 0 0 1 0 0 0 0 0 1 1 (位置 1 到 10)</li>
<li>输出 (K2): 01000011</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>最终，我们从主密钥 1010000010 得到了两个子密钥:
K1 = 10100100
K2 = 01000011</p>
<h3 id="22-s-des-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3">2.2 S-DES 加密流程详解</h3>
<ol>
<li><strong>初始置換 (IP - Initial Permutation)</strong>
<ul>
<li><strong>工作原理</strong>：IP是一个固定的置换表，它将输入的8个比特按照一个预设的规则重新排列位置。</li>
<li><strong>互逆关系</strong>：每一个置换操作（IP），都有一个唯一的逆置换操作（IP^-1）。如果在IP操作之后立即执行IP^-1操作，数据就会恢复到原始的顺序。</li>
<li><strong>作用</strong>：在DES设计的年代，初始和最终置换主要是为了方便数据在硬件上的加载。从现代密码学角度看，它们不提供任何加密强度。</li>
</ul>
</li>
<li><strong>第一轮 (使用K1)</strong>
<ul>
<li>将经过IP置换的数据分为左右各4位 (L0, R0)。</li>
<li><strong>轮函数 f(R0, K1)</strong>：这是S-DES最核心的部分。
<ol>
<li><strong>扩展/置换 (E/P)</strong>：将4位的右半部分R0扩展成8位，以便和8位的子密钥进行异或。</li>
<li><strong>与子密钥 K1 异或</strong>：将E/P扩展后的8位数据与8位的子密钥K1进行按位异或（XOR）操作。</li>
<li><strong>S盒代换</strong>：将异或后的8位数据分为两半，分别输入S0盒和S1盒（4位输入，2位输出）。这是算法中唯一的非线性组件，是安全性的关键。</li>
<li><strong>P4置换</strong>：将两个S盒输出的2位结果（共4位）合并，再通过P4置换表进行最后一次重排，得到轮函数最终结果。</li>
</ol>
</li>
<li><strong>计算第一轮输出 (L1, R1)</strong>：
<ul>
<li>L1 = R0</li>
<li>R1 = L0 XOR f(R0, K1)</li>
</ul>
</li>
</ul>
</li>
<li><strong>中间交换 (SW - Swap)</strong>
<ul>
<li><strong>工作原理</strong>：这是一个简单的操作，<strong>就是将第一轮生成的左右两半 (L1, R1) 的位置互换</strong>，得到 (R1, L1)。</li>
<li><strong>作用</strong>：将交换后的结果 (R1, L1) 作为第二轮轮函数的输入。这是S-DES结构的一个特定步骤，在DES中并不是。</li>
</ul>
</li>
<li><strong>第二轮 (使用K2)</strong>
<ul>
<li>将交换后的数据 (R1, L1) 作为输入，重复整个轮函数过程，但这一次使用的是第二个子密钥 K2。</li>
<li><strong>计算第二轮输出 (L2, R2)</strong>：
<ul>
<li>L2 = L1</li>
<li>R2 = R1 XOR f(L1, K2)</li>
</ul>
</li>
<li><strong>注意</strong>：在最后一轮之后，<strong>不再进行交换</strong>。</li>
</ul>
</li>
<li><strong>逆初始置换 (IP^-1)</strong>
<ul>
<li>将第二轮的输出 (L2, R2) 合并，然后通过逆初始置换表得到最终的8位密文。</li>
</ul>
</li>
</ol>
<h4 id="221-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B">2.2.1 加密流程实例</h4>
<p>假设 明文 P = (01101011)，使用上一节生成的子密钥 K1 = 10100100 和 K2 = 01000011。置换表和S盒如下：</p>
<ul>
<li>IP: (2, 6, 3, 1, 4, 8, 5, 7)</li>
<li>E/P: (4, 1, 2, 3, 2, 3, 4, 1)</li>
<li>P4: (2, 4, 3, 1)</li>
<li>IP^-1: (4, 1, 3, 5, 7, 2, 8, 6)</li>
<li>S0盒: [[1,0,3,2], [3,2,1,0], [0,2,1,3], [3,1,3,2]]</li>
<li>S1盒: [[0,1,2,3], [2,0,1,3], [3,0,1,0], [2,1,0,3]]</li>
</ul>
<ol>
<li><strong>初始置换 (IP)</strong>
<ul>
<li>输入 (P): 01101011</li>
<li>输出: 10100111</li>
<li>分割: L0 = 1010, R0 = 0111</li>
</ul>
</li>
<li><strong>第一轮 (使用 K1 = 10100100)</strong>
<ul>
<li><strong>轮函数 f(R0, K1)</strong>:
<ul>
<li>E/P扩展 (对R0 = 0111): 输出 10111110</li>
<li>异或 K1: 10111110 XOR 10100100 = 00011010</li>
<li>S盒代换:
<ul>
<li>S0盒输入: 0001 -&gt; 行1, 列0 -&gt; 查表得3 -&gt; 二进制 11</li>
<li>S1盒输入: 1010 -&gt; 行2, 列1 -&gt; 查表得0 -&gt; 二进制 00</li>
<li>S盒总输出: 1100</li>
</ul>
</li>
<li>P4置换 (对1100): 输出 1001 (轮函数最终结果)</li>
</ul>
</li>
<li><strong>计算 L1, R1</strong>:
<ul>
<li>L1 = R0 = 0111</li>
<li>R1 = L0 XOR (P4结果) = 1010 XOR 1001 = 0011</li>
</ul>
</li>
<li>第一轮输出为 (L1, R1) = (0111, 0011)</li>
</ul>
</li>
<li><strong>中间交换 (SW)</strong>
<ul>
<li>交换L1和R1的位置，作为第二轮的输入。</li>
<li>第二轮输入: (R1, L1) = (0011, 0111)</li>
</ul>
</li>
<li><strong>第二轮 (使用 K2 = 01000011)</strong>
<ul>
<li><strong>轮函数 f(L1, K2)</strong>: (注意，此时轮函数操作对象是 L1 = 0111)
<ul>
<li>E/P扩展 (对L1 = 0111): 输出 10111110</li>
<li>异或 K2: 10111110 XOR 01000011 = 11111101</li>
<li>S盒代换:
<ul>
<li>S0盒输入: 1111 -&gt; 行3, 列3 -&gt; 查表得2 -&gt; 二进制 10</li>
<li>S1盒输入: 1101 -&gt; 行3, 列2 -&gt; 查表得0 -&gt; 二进制 00</li>
<li>S盒总输出: 1000</li>
</ul>
</li>
<li>P4置换 (对1000): 输出 0001 (轮函数最终结果)</li>
</ul>
</li>
<li><strong>计算 L2, R2</strong>:
<ul>
<li>L2 = L1 = 0111</li>
<li>R2 = R1 XOR (P4结果) = 0011 XOR 0001 = 0010</li>
</ul>
</li>
<li>第二轮输出 (最终输出): (L2, R2) = (0111, 0010)</li>
</ul>
</li>
<li><strong>逆初始置换 (IP^-1)</strong>
<ul>
<li>输入: 01110010 (合并L2, R2)</li>
<li>输出 (密文 C): 10101100</li>
</ul>
</li>
</ol>
<p>因此，明文 01101011 经过S-DES加密后，得到的密文为 10101100。</p>
<h3 id="23-s-des-%E8%A7%A3%E5%AF%86%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3">2.3 S-DES 解密流程详解</h3>
<p>S-DES的解密是加密的逆过程。通过逆序使用子密钥（先用K2，再用K1）并应用Feistel结构的逆向公式，可以从密文恢复出明文。</p>
<p>我们从加密的最终状态 (L2, R2)（即 IP(C)）开始回溯。</p>
<p><strong>加密过程回顾:</strong></p>
<ul>
<li>第一轮后: (L1, R1) 其中 L1 = R0 且 R1 = L0 XOR f(R0, K1)</li>
<li>交换后: (R1, L1)</li>
<li>第二轮后: (L2, R2) 其中 L2 = L1 且 R2 = R1 XOR f(L1, K2)</li>
</ul>
<p><strong>解密推导 (从 L2, R2 开始):</strong></p>
<ol>
<li><strong>恢复 (R1, L1) (使用 K2):</strong>
<ul>
<li>根据第二轮加密公式 L2 = L1，我们可以直接得到 L1 = L2。</li>
<li>根据第二轮加密公式 R2 = R1 XOR f(L1, K2)，利用异或的自反性，我们可以推导出 R1 = R2 XOR f(L1, K2)。因为已经知道 L1=L2，所以 R1 = R2 XOR f(R2, K2)。</li>
<li>至此，我们已经从 (L2, R2) 恢复出了 (R1, L1)。</li>
</ul>
</li>
<li><strong>撤销交换 (SW^-1):</strong>
<ul>
<li>加密过程中有 (L1, R1) -&gt; SW -&gt; (R1, L1) 的步骤。</li>
<li>因此，我们将上一步恢复的 (R1, L1) 交换回来，得到 (L1, R1)。</li>
</ul>
</li>
<li><strong>恢复 (L0, R0) (使用 K1):</strong>
<ul>
<li>根据第一轮加密公式 L1 = R0，我们可以直接得到 R0 = L1。</li>
<li>根据第一轮加密公式 R1 = L0 XOR f(R0, K1)，我们可以推导出 L0 = R1 XOR f(R0, K1)。因为已经知道 R0=L1，所以 L0 = R1 XOR f(L1, K1)。</li>
<li>至此，我们已经从 (L1, R1) 恢复出了 (L0, R0)，这正是初始置换后的明文。</li>
</ul>
</li>
</ol>
<p>最后，对 (L0, R0) 执行逆初始置换 IP^-1 即可得到原始明文P。</p>
<h2 id="3-des-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">3. DES (数据加密标准)</h2>
<p>DES是真正被广泛应用的加密标准，其结构比S-DES复杂得多，但基本原理——Feistel网络、S盒、P盒、密钥调度——是完全一致的。</p>
<ul>
<li><strong>输入</strong>：64位明文，64位密钥（其中56位有效，8位为奇偶校验位）。</li>
<li><strong>输出</strong>：64位密文。</li>
<li><strong>核心结构</strong>：一个包含16轮的Feistel网络。</li>
</ul>
<h3 id="31-des-%E5%8A%A0%E5%AF%86%E4%B8%BB%E6%B5%81%E7%A8%8B">3.1 DES 加密主流程</h3>
<ol>
<li><strong>初始置换 (IP)</strong>：对64位明文块进行初始重排。</li>
<li><strong>16轮Feistel迭代</strong>：
<ul>
<li>将数据分为左右两个32位的块 (L0, R0)。</li>
<li>对每一轮 i (从1到16)执行相同的轮函数：
<ul>
<li>L(i) = R(i-1)</li>
<li>R(i) = L(i-1) XOR F(R(i-1), K(i))</li>
</ul>
</li>
</ul>
</li>
<li><strong>最终交换</strong>：完成16轮后，得到(L16, R16)。将左右两半进行最后一次交换，形成 (R16, L16)。</li>
<li><strong>逆初始置换 (IP^-1)</strong>：对交换后的64位数据进行逆置换，得到最终的64位密文。</li>
</ol>
<h3 id="32-des-%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E8%AF%A6%E8%A7%A3">3.2 DES 密钥生成详解</h3>
<p>从64位主密钥生成16个48位的子密钥，过程比S-DES复杂。</p>
<ol>
<li><strong>PC-1置换 (置换选择1)</strong>：从64位输入密钥中去掉8个校验位（每字节的第8位），并对剩下的56位进行置换。</li>
<li><strong>分割</strong>：将56位分为左右两个28位 (C0, D0)。</li>
<li><strong>16轮迭代生成</strong>：
<ul>
<li>对于第 i 轮 (i 从 1 到 16)：
<ul>
<li><strong>循环左移</strong>：根据一个预设的调度表，将 C(i-1) 和 D(i-1) 分别循环左移1位或2位，得到 C(i) 和 D(i)。在第1, 2, 9, 16轮移1位，其余轮移2位。</li>
<li><strong>PC-2置换 (置换选择2)</strong>：将 C(i) 和 D(i) 合并成56位，并通过PC-2置换表进行压缩，从56位中选出48位，得到该轮的子密钥 K(i)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="file:///d:/code/Notes/密码学笔记/image/第3章分组密码与DES学习笔记/1762868903683.png" alt="1762868903683"></p>
<h3 id="33-des-%E8%BD%AE%E5%87%BD%E6%95%B0-f-%E8%AF%A6%E8%A7%A3">3.3 DES 轮函数 f 详解</h3>
<p><strong>DES 单轮函数 f 内部流程图</strong>:</p>
<pre class="hljs"><code><div>右半部分 R(i-1) (32位)
        |
+------------------+
|    扩展置换 E    |
|  (32位 -&gt; 48位)  |
+------------------+
        |
        v
子密钥 K(i) -------&gt; +-----(XOR)-----&gt; (48位)
                       |
                       v
+------------------+
| S盒代换 (S1...S8)|
|  (48位 -&gt; 32位)  |
+------------------+
        |
        v
+------------------+
|    P盒置换 P     |
+------------------+
        |
        v
轮函数 f 的输出 (32位)
</div></code></pre>
<ol>
<li><strong>扩展置换 (E)</strong>：
<ol>
<li>将32位输入 R(i-1) 扩展为48位，为了让数据与48位的本轮子密钥长度匹配。</li>
<li>置换同时能产生雪崩效应。</li>
</ol>
</li>
<li><strong>密钥混合</strong>：将扩展后的48位数据与48位的本轮子密钥 K(i) 进行异或。</li>
<li><strong>S盒代换</strong>：
<ol>
<li>将48位结果分为8个6位的块，每个块送入一个对应的S盒（S1-S8）。</li>
<li>每个S盒是一个固定的查找表，将6位输入转换为4位输出。这是DES中唯一的非线性操作，是其安全性的关键。</li>
</ol>
</li>
<li><strong>P盒置换</strong>：将8个S盒输出的（共32位）数据进行一次简单的置换，以进一步增强扩散效果。</li>
</ol>
<h3 id="34-des-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B">3.4 DES 加密流程实例</h3>
<p>为简明起见，我们仅详细演算第一轮，并简述后续过程。</p>
<ul>
<li><strong>明文 P (Hex)</strong>: 0123456789ABCDEF</li>
<li><strong>密钥 K (Hex)</strong>: 133457799BBCDFF1</li>
<li><strong>预期密文 C (Hex)</strong>: 85E813540F0AB405</li>
</ul>
<ol>
<li><strong>初始置换 (IP)</strong>
<ul>
<li>对64位的明文P进行IP置换，得到置换后的数据IP(P)。</li>
<li>IP(P) (Hex): C000C000F0AAF0AA</li>
<li>分割为 L0 和 R0 (各32位):
<ul>
<li>L0 (Hex): C000C000</li>
<li>R0 (Hex): F0AAF0AA</li>
</ul>
</li>
</ul>
</li>
<li><strong>子密钥生成 (仅K1)</strong>
<ul>
<li>对64位密钥K进行PC-1置换，得到56位的C0和D0。</li>
<li>对C0和D0进行1位循环左移，得到C1和D1。</li>
<li>将C1和D1合并，并通过PC-2置换，得到第一个48位的子密钥K1。</li>
<li>K1 (Hex): 1B1A011728033834</li>
</ul>
</li>
<li><strong>第一轮 (使用 K1)</strong>
<ul>
<li>
<p><strong>计算轮函数 f(R0, K1)</strong>:</p>
<ol>
<li><strong>扩展R0</strong>: 将32位的R0通过扩展置换E表，扩展为48位。</li>
<li><strong>异或K1</strong>: 将扩展后的R0与48位的K1进行异或。</li>
<li><strong>S盒代换</strong>: 将异或结果分为8组（每组6位），分别输入8个S盒，得到8个4位输出，合并为32位。</li>
<li><strong>P盒置换</strong>: 对S盒的32位输出进行P盒置换，得到轮函数的最终结果。</li>
<li>f(R0, K1) 的计算结果 (Hex): 20008041</li>
</ol>
</li>
<li>
<p><strong>计算 L1, R1</strong>:</p>
<ul>
<li>L1 = R0 = 0111</li>
<li>R1 = L0 XOR f(R0, K1) = 1010 XOR 1001 = 0011</li>
</ul>
</li>
<li>
<p>第一轮输出为 (L1, R1) = (0111, 0011)</p>
</li>
</ul>
</li>
<li><strong>后续15轮</strong>
<ul>
<li>将 (L1, R1) 作为第二轮的输入，使用子密钥K2重复上述过程，得到(L2, R2)。</li>
<li>... 此过程共迭代16次，直到计算出 (L16, R16)。</li>
</ul>
</li>
<li><strong>最终交换与逆初始置换 (IP^-1)</strong>
<ul>
<li>经过16轮后，得到 L16, R16。</li>
<li>进行最后一次交换，得到 (R16, L16)。</li>
<li>将 (R16, L16) 合并，并执行逆初始置换 (IP^-1)，最终得到64位密文。</li>
<li>密文 C (Hex): 85E813540F0AB405</li>
</ul>
</li>
</ol>
<h3 id="35-des-%E8%A7%A3%E5%AF%86%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3">3.5 DES 解密流程详解</h3>
<p>DES解密过程是加密过程的逆运算。其核心在于Feistel结构允许使用完全相同的轮函数F，只需从头开始，但按相反的顺序提供子密钥（从K16到K1）。</p>
<p><strong>加密终态回顾:</strong> 加密的最后几步是将第16轮的输出 (L16, R16) 进行交换，得到 (R16, L16)，然后执行 IP^-1 得到密文 C。 即: C = IP^-1(R16, L16)。</p>
<p><strong>解密流程公式推导:</strong></p>
<ol>
<li><strong>逆向初始置换:</strong>
<ul>
<li>首先对密文 C 执行初始置换 IP，这会撤销加密的最后一步 IP^-1。</li>
<li>IP(C) = IP(IP^-1(R16, L16)) = (R16, L16)。</li>
<li>我们将这个结果作为解密第一轮的输入，记为 (D0_L, D0_R)，所以 D0_L = R16 且 D0_R = L16。</li>
</ul>
</li>
<li><strong>解密第一轮 (使用K16):</strong>
<ul>
<li>输入为 (D0_L, D0_R) = (R16, L16)。</li>
<li>计算输出 (D1_L, D1_R)：
<ul>
<li>D1_L = L16</li>
<li>D1_R = R16 XOR f(L16, K16)</li>
</ul>
</li>
<li>根据加密公式：L16 = R15, R16 = L15 XOR f(R15, K16)。</li>
<li>替换后：
<ul>
<li>D1_L = L15</li>
<li>D1_R = L15</li>
</ul>
</li>
<li>第一轮解密输出为 (D1_L, D1_R) = (L15, R15)。</li>
</ul>
</li>
<li><strong>解密第二轮 (使用K15):</strong>
<ul>
<li>输入为 (D1_L, D1_R) = (L15,R15)。</li>
<li>同理，应用轮函数和密钥 K15，输出 (D2_L, D2_R) 将会是 (R14, L14)。</li>
</ul>
</li>
<li><strong>... (后续13轮)</strong></li>
<li><strong>解密第十六轮 (使用K1):</strong>
<ul>
<li>经过15轮解密后，输入为 (D15_L, D15_R) = (R1, L1)。</li>
<li>应用轮函数和密钥 K1，输出 (D16_L, D16_R):
<ul>
<li>D16_L = D15_R = L1</li>
<li>D16_R = D15_L XOR F(D15_R, K1) = R1 XOR F(L1, K1)</li>
</ul>
</li>
<li>根据加密第一轮的公式 L1 = R0 且 R1 = L0 XOR F(R0, K1)，我们进行替换：
<ul>
<li>D16_L 变为 R0。</li>
<li>D16_R 变为 (L0 XOR F(R0, K1)) XOR F(R0, K1)，化简为 L0。</li>
</ul>
</li>
<li>因此，16轮解密后的最终输出是 (R0, L0)。</li>
</ul>
</li>
<li><strong>最终交换:</strong>
<ul>
<li>我们得到的 (R0, L0) 是加密初始状态 (L0, R0) 的左右交换形式。为了恢复原始顺序，需要执行一次交换。</li>
<li>(R0, L0) -&gt; SWAP -&gt; (L0, R0)。</li>
</ul>
</li>
<li><strong>逆初始置换 (IP^-1):</strong>
<ul>
<li>对 (L0, R0) 执行 IP^-1，即可得到原始明文 P。</li>
<li>P = IP^-1(L0, R0)。</li>
</ul>
</li>
</ol>
<h2 id="4-des-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90">4. DES 的设计原理与密码分析</h2>
<h3 id="41-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86">4.1 设计原理</h3>
<p>DES 的设计遵循“混乱”和“扩散”两大原则：</p>
<ol>
<li>
<p><strong>混乱 (Confusion)</strong></p>
<ul>
<li>通过 S 盒（S-boxes）实现非线性替换，隐藏密钥与密文之间的关系。</li>
<li>S 盒将输入的 6 位数据映射为 4 位输出，打乱线性关系，使密钥的微小变化导致密文的显著变化。</li>
</ul>
</li>
<li>
<p><strong>扩散 (Diffusion)</strong></p>
<ul>
<li>通过 P 盒（P-boxes）和 Feistel 结构实现明文变化的传播。</li>
<li>P 盒重新排列 S 盒输出的位，增强数据的扩散效果。</li>
<li>Feistel 结构通过左右数据块的交替处理和 16 轮迭代，将明文的微小变化扩散到整个密文块。</li>
</ul>
</li>
</ol>
<p>这两者的结合确保了 DES 的安全性，使得攻击者难以通过分析密文推断明文或密钥。</p>
<h3 id="42-%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%BC%BA%E5%BA%A6">4.2 密码分析与强度</h3>
<ul>
<li><strong>密钥长度</strong>：DES的56位密钥是其最大的弱点。在现代计算能力下，2^56 种可能的密钥可以通过**暴力破解（Brute-force Attack）**在很短时间内被穷尽。</li>
<li><strong>差分密码分析</strong>：一种选择明文攻击。DES的16轮结构和S盒设计使其具有较强的抗差分分析能力。</li>
<li><strong>线性密码分析</strong>：一种已知明文攻击。通过找到加密过程中明文、密钥、密文之间的线性近似关系来破解密码。</li>
</ul>
<h2 id="5-des-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-modes-of-operation">5. DES 的工作模式 (Modes of Operation)</h2>
<p>为了加密长度超过64位的消息，需要定义不同的工作模式。</p>
<h3 id="51-%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E6%9C%AC-electronic-codebook---ecb">5.1 电子密码本 (Electronic Codebook - ECB)</h3>
<ul>
<li><strong>工作方式</strong>：最简单的模式，每个明文块都独立地使用相同的密钥进行加密。</li>
<li><strong>公式</strong>：C(i) = E(K, P(i))</li>
<li><strong>优点</strong>：简单，可并行计算。</li>
<li><strong>缺点</strong>：<strong>极其不安全！</strong> 相同的明文块会产生相同的密文块，无法隐藏数据模式。</li>
</ul>
<h3 id="52-%E5%AF%86%E7%A0%81%E5%88%86%E7%BB%84%E9%93%BE%E6%8E%A5-cipher-block-chaining---cbc">5.2 密码分组链接 (Cipher Block Chaining - CBC)</h3>
<ul>
<li><strong>工作方式</strong>：在加密当前明文块之前，先将其与前一个密文块进行异或。第一个块需要一个初始向量 (IV)。</li>
<li><strong>公式</strong>：C(i) = E(K, P(i) XOR C(i-1)) (其中 C(0) = IV)</li>
<li><strong>优点</strong>：隐藏了明文的模式，是应用最广泛的模式之一。</li>
<li><strong>缺点</strong>：加密过程是串行的，无法并行。</li>
</ul>
<h3 id="53-%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-counter---ctr">5.3 计数器模式 (Counter - CTR)</h3>
<ul>
<li><strong>工作方式</strong>：将分组密码变成一个流密码。它加密一个“计数器”值，然后将加密结果与明文块异或。</li>
<li><strong>公式</strong>：C(i) = P(i) XOR E(K, Counter(i))</li>
<li><strong>优点</strong>：可以并行计算，可随机访问数据块，效率高。</li>
<li><strong>缺点</strong>：计数器值决不能与同一密钥重用，否则会造成严重的安全问题。</li>
</ul>
<h2 id="6-sw-%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BD%9C%E7%94%A8">6. SW 操作的作用</h2>
<h3 id="61-sw-%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BD%9C%E7%94%A8">6.1 SW 操作的作用</h3>
<h4 id="%F0%9F%A7%A9-%E4%B8%80des-%E6%AF%8F%E8%BD%AE%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">🧩 一、DES 每轮迭代的基本结构</h4>
<p>DES 是典型的 <strong>Feistel 网络</strong>，每一轮迭代关系为：</p>
<p>$$
\begin{cases}
L_i = R_{i-1} \
R_i = L_{i-1} \oplus f(R_{i-1}, K_i)
\end{cases}
$$</p>
<h4 id="%F0%9F%94%81-%E4%BA%8C16-%E8%BD%AE%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C">🔁 二、16 轮后的结果</h4>
<p>经过 16 轮后得到：</p>
<p>$$
(L_{16}, R_{16})
$$</p>
<h4 id="%F0%9F%A7%AE-%E4%B8%89%E6%83%85%E5%86%B5-1%E6%89%A7%E8%A1%8C-sw%E6%A0%87%E5%87%86-des">🧮 三、<strong>情况 1：执行 SW（标准 DES）</strong></h4>
<p>加密结束后，DES 会 <strong>交换左右两半</strong>：</p>
<p>$$
\text{输出为 } (R_{16}, L_{16})
$$</p>
<p>然后再经过逆初始置换 ( $IP^{-1}$ )。</p>
<h5 id="%F0%9F%94%93-%E8%A7%A3%E5%AF%86%E6%97%B6">🔓 解密时</h5>
<p>设密文经过初始置换 ( $IP$ ) 后为：</p>
<p>$$
(L_0', R_0') = (R_{16}, L_{16})
$$</p>
<p>则第 1 轮解密（使用子密钥逆序 $K_{16}, K_{15}, \dots, K_1$）仍然遵循相同结构：</p>
<p>$$
\begin{cases}
L_i' = R_{i-1}' \
R_i' = L_{i-1}' \oplus f(R_{i-1}', K_{17-i})
\end{cases}
$$</p>
<p>我们验证第 1 轮：</p>
<p>$$
L_1' = R_0' = L_{16}
$$</p>
<p>$$
R_1' = L_0' \oplus f(R_0', K_{16}) = R_{16} \oplus f(L_{16}, K_{16})
$$</p>
<p>而根据加密第 16 轮的定义：</p>
<p>$$
R_{16} = L_{15} \oplus f(R_{15} = L_{16} , K_{16})
$$</p>
<p>因此：</p>
<p>$$
R_1' = ( L_{15} \oplus f(R_{15}, K_{16})) \oplus f(R_{15}, K_{16}) = L_{15}
$$</p>
<p>于是我们得到：</p>
<p>$$
(L_1', R_1') = (L_{16}, L_{15})
$$</p>
<p>即回到前一轮的状态（对称成立）。</p>
<p>✅ <strong>结论</strong>：执行 SW 后，解密能正确反推每一轮，只需反转密钥顺序即可。</p>
<h4 id="%E2%9D%8C-%E5%9B%9B%E6%83%85%E5%86%B5-2%E4%B8%8D%E6%89%A7%E8%A1%8C-sw">❌ 四、<strong>情况 2：不执行 SW</strong></h4>
<p>若不交换，输出即为：</p>
<p>$$
(L_{16}, R_{16})
$$</p>
<h5 id="%E8%A7%A3%E5%AF%86%E6%97%B6%E4%BB%8D%E7%84%B6%E6%89%A7%E8%A1%8C-ip">解密时（仍然执行 $IP$）</h5>
<p>此时：</p>
<p>$$
(L_0', R_0') = (L_{16}, R_{16})
$$</p>
<p>如果继续使用同样的轮结构和反序密钥：</p>
<p>$$
\begin{cases}
L_i' = R_{i-1}' \
R_i' = L_{i-1}' \oplus f(R_{i-1}', K_{17-i})
\end{cases}
$$</p>
<p>第 1 轮时：</p>
<p>$$
L_1' = R_0' = R_{16}
$$</p>
<p>$$
R_1' = L_0' \oplus f(R_0', K_{16}) = L_{16} \oplus f(R_{16}, K_{16})
$$</p>
<p>而加密的第 16 轮为：</p>
<p>$$
R_{16} = L_{15} \oplus f(R_{15}, K_{16})
$$</p>
<p>且 $L_{16} = R_{15}$</p>
<p>代入可得：</p>
<p>$$
R_1' = R_{15} \oplus f(L_{15} \oplus f(R_{15}, K_{16}), K_{16})
$$</p>
<p>这已经<strong>无法化简回 $L_{15}$</strong>，说明结构错位、不可对称。</p>
<h4 id="%F0%9F%A7%AD-%E4%BA%94%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93">🧭 五、对比总结</h4>
<table>
<thead>
<tr>
<th>情况</th>
<th>输出顺序</th>
<th>解密时输入</th>
<th>结构关系</th>
<th>能否对称复用</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 执行 SW</td>
<td>$(R_{16}, L_{16})$</td>
<td>$(L_0′, R_0′) = (R_{16}, L_{16})$</td>
<td>对称回溯成立</td>
<td>✅ 可以</td>
</tr>
<tr>
<td>❌ 不执行 SW</td>
<td>$(L_{16}, R_{16})$</td>
<td>$(L_0′, R_0′) = (L_{16}, R_{16})$</td>
<td>无法还原每轮</td>
<td>❌ 不行</td>
</tr>
</tbody>
</table>
<h4 id="%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93">✅ 一句话总结</h4>
<blockquote>
<p>DES 最后一轮后的 SW 操作（交换 $L_{16}$ 和 $R_{16}$）是为了保证加解密过程在 Feistel 结构上完全对称，使得解密时仅需反转密钥顺序即可恢复原文。
若不交换，结构错位，解密将无法简单复用同样的轮函数。</p>
</blockquote>
<h3 id="62-%E4%B8%BB%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%AF%B4%E6%98%8E">6.2 主密钥长度与密码安全性说明</h3>
<h4 id="1-%E5%AF%86%E9%92%A5%E7%A9%BA%E9%97%B4%E4%B8%8E%E8%9B%AE%E5%8A%9B%E6%94%BB%E5%87%BB">1. 密钥空间与蛮力攻击</h4>
<ul>
<li>主密钥的长度 $k$ 决定了密钥空间的大小：$2^k$。</li>
<li>密钥空间越大，蛮力攻击（Brute-Force Attack）破解密码的难度越高。
<ul>
<li><strong>SDES 的 10 bit 密钥</strong>：$2^{10} = 1024$ 种可能，现代计算机可在毫秒内穷尽。</li>
<li><strong>AES 的 128 bit 密钥</strong>：$2^{128}$ 是天文数字，穷尽所有可能需要超过宇宙的寿命。</li>
</ul>
</li>
</ul>
<h4 id="2-sdes-%E5%92%8C-des-%E7%9A%84%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6%E8%AE%BE%E8%AE%A1">2. SDES 和 DES 的密钥长度设计</h4>
<ul>
<li><strong>SDES 的 10 bit 密钥</strong>：
<ul>
<li>设计为教学用途，便于手工计算和理解加密原理。</li>
<li>不追求安全性，仅用于演示。</li>
</ul>
</li>
<li><strong>DES 的 56 bit 密钥</strong>：
<ul>
<li>1970年代的权衡结果，当时 $2^{56}$ 足够抵抗蛮力攻击。</li>
<li>随着计算能力提升，1990年代已被证明不安全。1998年，专用设备“Deep Crack”几天内破解了 DES。</li>
</ul>
</li>
</ul>
<h4 id="3-%E4%B8%BB%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%AD%90%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90">3. 主密钥长度与子密钥生成</h4>
<ul>
<li>主密钥通过密钥生成算法扩散为多轮子密钥（如 DES 的 16 轮，每轮 48 bit）。</li>
<li><strong>主密钥过短的风险</strong>：
<ul>
<li>原材料不足导致子密钥间存在数学关联性，易被分析攻击（如关联密钥攻击）利用。</li>
<li>例如，用 SDES 的 10 bit 密钥生成 DES 的子密钥，安全性会大幅降低。</li>
</ul>
</li>
</ul>

</body>
</html>
