# **第八章：数字签名和认证协议 \- 学习笔记**

## **第一部分：数字签名 (Digital Signature)**

**MAC** 可以验证消息的完整性和来源，但不具备不可否认性。**数字签名**正是为了解决这个问题而生的。

### **1.1数字签名工作方式**：

* 1. **签名方 A**：用自己的**私钥 KR\_a** 对消息的哈希值进行加密（或者说“签名”），Signature \= E(KR\_a, H(M))。
  2. **验证方 B**：用 A 的**公钥 KU\_a** 来解密签名，得到一个哈希值 H1，H1 \= D(KU\_a, Signature)。同时，B 自己计算接收到消息 M 的哈希值 H2。如果 H1 \== H2，签名就验证通过。
* **核心区别**：因为只有 A 拥有私钥 KR\_a，所以只有 A 能生成这个签名。任何人都可以用公开的 KU\_a 来验证。这样 A 就无法否认自己的签名了，这就实现了**不可否认性**。

### **1.2 应用实例：网上银行转账**

假设你要通过网上银行给朋友转账 5000 元。

1. **生成交易信息 (M)**：M \= “从账户A转账5000元至账户B”。
2. **计算哈希**：客户端（如手机App）用 **SHA-256** 计算出 H(M)。
3. **进行签名**：你授权客户端使用你的**个人私钥 (KR\_a)** 对 H(M) 进行加密，生成数字签名 Signature。
4. **发送给银行**：客户端将原始指令 M 和签名 Signature 一起发送给银行服务器。
5. **银行验证**：银行用你的**公钥 (KU\_a)** 解密签名，并对比哈希值。如果一致，就确认这是你本人发出的、不可否认的指令，然后执行转账。**如果事后发生纠纷，这个数字签名就是具有法律效力的证据。**

## **第二部分：认证协议与重放攻击**

**2.1 应用实例：网站登录防重放**

为防止攻击者截获你的密码哈希并重放，安全登录流程如下：

1. **服务器发出挑战**：服务器生成一个一次性的、随机的字符串（**Nonce**），例如 nonce \= "abcdefg12345"，并发送给你的浏览器。
2. **客户端计算响应**：你的浏览器将你的密码哈希 H(password) 和服务器发来的 nonce 结合起来，再次进行哈希计算，Response \= H(H(password) \+ nonce)。
3. **服务器验证**：服务器用同样的方式计算出期望的响应值，如果与浏览器发来的一致，则认证成功。
4. **如何防止重放**？ 下一次登录时，服务器会生成一个全新的 Nonce，攻击者手里的旧 Response 会立刻失效。

## **第三部分：认证应用一：Kerberos**

**3.1 一个基于对称加密的大型密钥管理系统**

Kerberos 整个体系完全建立在**对称加密**之上，是**密钥管理**知识的一个宏大实践。它的核心是一个所有人都信任的**密钥分发中心 (KDC)**，通过分发临时的**会话密钥**来保证通信安全。

**3.2 核心组件**

1. **认证服务器 (Authentication Server \- AS)**：验证你的初始身份，并发放 TGT（Ticket-Granting Ticket，票据授权票据）。
2. **票据授权服务器 (Ticket-Granting Server \- TGS)**：你凭借 TGT 向它请求访问具体服务的许可。
3. **票据 (Ticket)**：一张加密的凭证，是你访问服务的"门票"。在Kerberos中主要有两种类型：

   * **TGT (Ticket-Granting Ticket)**：用于向TGS请求服务票据的凭证
   * **服务票据 (Service Ticket)**：用于访问特定应用服务器的凭证

**3.3 TicketV 的详细构成 (补充自PPT第19页)**

一张发往服务器V的票据 Ticket\_v 的内部结构如下：Ticket\_v \= E(K\_v, \[ ID\_c || AD\_c || ID\_v || Lifetime || K\_cv \])

* E(K\_v, ...): 整个票据是用**服务V的主密钥 (K\_v)** 加密的。只有服务器V能解开。
* ID\_c: 你的用户ID，告诉服务器你是谁。
* AD\_c: 你的网络地址（IP地址），防止票据在别的机器上被盗用。
* ID\_v: 服务器V的ID。
* Lifetime: 票据的有效期，防止被无限期重放。
* K\_cv: **会话密钥**。这是KDC为你和服务器V生成的临时通信密钥，服务器V解密票据后得到它，你们后续的通信就用这个密钥加密。

**3.4 Kerberos 认证流程**

Kerberos认证系统是一个三方认证协议，涉及三个核心组件的协作：认证服务器(AS)、票据授权服务器(TGS)和应用服务器(V)。以下是**完整的认证流程**：

**第一阶段：用户A向认证服务器AS请求认证**

1. **用户A请求认证**：用户A向AS发送认证请求，包含用户身份标识。
2. **AS验证用户身份**：AS检查要求登录系统的用户A的密码的有效性，验证用户的合法性。
3. **AS颁发TGT**：验证通过后，AS颁发一个TGS的票据授权票据（Ticket-Granting Ticket, TGT）给用户A，使得A可以进入TGS进行后续服务请求。

**第二阶段：用户A向票据授权服务器TGS请求服务票据**

1. **A请求服务票据**：用户A携带TGT向TGS请求访问特定应用服务器V的服务。
2. **TGS验证TGT**：TGS检查用户A发送的TGT的有效性，确认用户已通过AS的认证。
3. **TGS处理服务请求**：TGS处理用户A的服务请求，生成相应的服务访问权限。
4. **TGS颁发服务票据**：TGS颁发一个服务授权票据（Service-Granting Ticket, TicketV）给用户A，使得A可以进入应用服务器V。

**第三阶段：用户A访问应用服务器V**

1. **A发送服务票据**：用户A将从TGS获得的TicketV发送给目标应用服务器V。
2. **服务器V验证票据**：应用服务器V检查用户A发送的TicketV的有效性。
3. **服务器V授权决策**：基于票据验证结果，应用服务器V对用户A的服务请求进行授权或拒绝。

**认证流程图**

```

```

**3.5 企业内部网络SSO应用实例**

你在公司早上登录电脑（Windows域环境）时：

1. **初始认证（第一阶段）**：当你输入用户名和密码时，这个过程就是向**AS**认证并获取TGT。AS验证你的域账户凭据后，会将TGT缓存在你的本地系统中。
2. **访问内部资源（第二、三阶段）**：之后，当你访问内部文件共享、打印机、邮件服务器等资源时：

   - 你的电脑会自动拿缓存的TGT去向**TGS**请求一张访问该特定服务的**服务票据**
   - TGS验证TGT的有效性后，发放相应的服务票据
   - 你的电脑再把这张服务票据出示给目标服务器（文件服务器、打印服务器等）
   - 服务器验证票据后，授权你的访问
3. **单点登录效果**：整个过程你只需要在开始时登录一次，即可在TGT有效期内无缝访问所有授权资源，这就是**单点登录 (Single Sign-On, SSO)**的核心价值。

**3.5 Kerberos 域 (Realm) 与跨域认证 (补充自PPT第22页)**

* **域 (Realm)**：一个独立的 Kerberos 管理单位（如一个部门、一个分公司），有自己独立的KDC。
* **跨域认证**：当“研发部”（域A）的用户需要访问“市场部”（域B）的服务器时，需要两个域的KDC预先建立信任。域A的KDC会给你一张指向域B的TGS的“介绍票据”，你再凭此票据向域B的TGS申请最终的服务票据。这使得Kerberos可以扩展到庞大的组织架构中。

**3.6 Kerberos安全机制的关键优势**

- **相互认证**：不仅验证用户身份，服务器身份也得到验证，防止恶意服务器攻击
- **时间戳防重放**：所有票据都包含时间戳，防止重放攻击
- **密钥隔离**：各服务使用独立的密钥，单个服务的密钥泄露不会影响整个系统
- **最小权限原则**：每个服务票据只授权访问特定服务，不能跨服务使用

## **第四部分：认证应用二：X.509**

**4.1 与旧知识的联系：公钥密码学 (RSA) 与 Hash 的终极应用**

X.509 和 PKI（公钥基础设施）体系是 **RSA** 和 **Hash 算法**最重要、最广泛的应用场景。它解决了公钥密码学最核心的难题：**公钥的分发和信任问题**。

* **证书的诞生**：一个证书的核心就是“**CA 用自己的私钥，对 ‘用户身份信息 \+ 用户的公钥’ 的哈希值进行签名**”。
  * Certificate\_Signature \= E(KR\_ca, H(User\_Info \+ KU\_user))
* **证书的验证**：任何人都可以用公开的 CA 公钥来验证这个签名，从而建立起对 KU\_user 这个公钥的信任。
* **信任链**：现实世界中，你的浏览器不可能内置所有网站的 CA 的公钥。它只内置了少数几个顶级“根CA”的公钥。一个网站的证书可能是由一个中间CA签发的，而这个中间CA的证书又是由另一个更高级的CA或根CA签发的。浏览器会逐级向上验证，直到找到它信任的根CA为止，形成一条完整的**信任链**。

**4.2 应用实例：安全的网上购物 (HTTPS)**

你打开浏览器，访问 https://www.amazon.com。

1. **服务器出示证书**：Amazon 的服务器会向你的浏览器发来它的 X.509 证书。
2. **浏览器验证证书**：
   * 浏览器看到证书的签发者是 “DigiCert”（一个著名的CA）。
   * 浏览器的信任库里内置了 DigiCert 这个根CA的公钥。
   * 浏览器使用 DigiCert 的公钥，对 Amazon 证书的签名进行解密验证，确认证书没有被篡改，并且确实是颁发给 www.amazon.com 这个域名的。
3. **建立安全信道**：
   * 验证通过后，浏览器就完全信任证书里的**Amazon公钥**了。
   * 浏览器生成一个用于本次通信的**对称密钥**（例如一个 AES 密钥，速度快）。
   * 浏览器用刚刚验证过的 **Amazon 公钥 (RSA)** 将这个对称密钥加密，然后发送给 Amazon 服务器。
4. **加密通信**：
   * 只有 Amazon 服务器能用自己的**私钥**解密，得到这个对称密钥。
   * 至此，你的浏览器和服务器都有了一个共同的、安全的对称密钥。之后你们之间所有的通信（包括你输入的信用卡号、收货地址等）都用这个对称密钥进行**高速加密**。

这个过程结合了非对称加密（用于安全地交换密钥）**和**对称加密（用于高效地加密数据）的优点，是你之前所学所有知识的一个完美综合应用。
